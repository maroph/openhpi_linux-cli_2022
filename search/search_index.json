{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"openHPI Kurs Linux in der Kommandozeile Vom 9. Februar 2022 bis 2. M\u00e4rz 2022 l\u00e4uft der openHPI Kurs Linux in der Kommandozeile . Diese Site ist meine Begleitseite zu diesem Kurs.","title":"Home"},{"location":"index.html#openhpi-kurs-linux-in-der-kommandozeile","text":"Vom 9. Februar 2022 bis 2. M\u00e4rz 2022 l\u00e4uft der openHPI Kurs Linux in der Kommandozeile . Diese Site ist meine Begleitseite zu diesem Kurs.","title":"openHPI Kurs Linux in der Kommandozeile"},{"location":"info/about.html","text":"\u00dcber diese Site Der gesamte Inhalt dieser Site (HTML und Skripte) ist abgelegt in meinem GitHub Repository . Benutzte Linux Versionen F\u00fcr meine Beispiele habe ich die folgenden Linux Versionen benutzt: Debian 11.2 on WSL2 (Windows Subsystem for Linux) echo $BASH_VERSION 5 .1.4 ( 1 ) -release Raspberry Pi OS 10.11 echo $BASH_VERSION 5 .0.3 ( 1 ) -release Struktur der Site Die Daten auf dieser Site sind folgenderma\u00dfen strukturiert: docs-src Markdown Sourcen dieser Site LICENSE Lizenz des Repositories (CC-BY 4.0) README.md Readme Datei des Repositories mkdocs.yml MkDocs Konfigurationsdatei MkDocs Virtual Environment F\u00fcr MkDocs verwende ich das folgende Virtual Environment: python3 -m venv venv source venv/bin/activate python -m pip install --upgrade pip python -m pip install --upgrade setuptools python -m pip install --upgrade wheel python -m pip install --upgrade mkdocs python -m pip install --upgrade mkdocs-material python -m pip install --upgrade mkdocs-git-revision-date-plugin Sollte das Modul venv nicht installiert sein, muss man das Package python3-venv installieren. Auf Debian/Ubuntu/Raspbian geht das mit dem folgenden Kommando sudo apt install python3-venv Lokale Erzeugung der Site ./build Ver\u00f6ffentlichung der Site F\u00fcr mein GitHub Repository habe ich die GitHub Page https://maroph.github.io/openhpi_linux-cli_2022/ konfiguriert. F\u00fcr diese GitHub Page werden die Daten aus dem Verzeichnis / im Branch gh-pages verwendet. Um diese Page zu aktualisieren, muss man die \u00c4nderungen im lokalen Git Repository committen und in das GitHub Repository pushen: git commit -m \"my commit message\" git push ./build deploy Nach einer relativ kurzen Zeit sind die \u00c4nderungen auf der GitHub Page zu sehen.","title":"\u00dcber"},{"location":"info/about.html#uber-diese-site","text":"Der gesamte Inhalt dieser Site (HTML und Skripte) ist abgelegt in meinem GitHub Repository .","title":"\u00dcber diese Site"},{"location":"info/about.html#benutzte-linux-versionen","text":"F\u00fcr meine Beispiele habe ich die folgenden Linux Versionen benutzt: Debian 11.2 on WSL2 (Windows Subsystem for Linux) echo $BASH_VERSION 5 .1.4 ( 1 ) -release Raspberry Pi OS 10.11 echo $BASH_VERSION 5 .0.3 ( 1 ) -release","title":"Benutzte Linux Versionen"},{"location":"info/about.html#struktur-der-site","text":"Die Daten auf dieser Site sind folgenderma\u00dfen strukturiert: docs-src Markdown Sourcen dieser Site LICENSE Lizenz des Repositories (CC-BY 4.0) README.md Readme Datei des Repositories mkdocs.yml MkDocs Konfigurationsdatei","title":"Struktur der Site"},{"location":"info/about.html#mkdocs-virtual-environment","text":"F\u00fcr MkDocs verwende ich das folgende Virtual Environment: python3 -m venv venv source venv/bin/activate python -m pip install --upgrade pip python -m pip install --upgrade setuptools python -m pip install --upgrade wheel python -m pip install --upgrade mkdocs python -m pip install --upgrade mkdocs-material python -m pip install --upgrade mkdocs-git-revision-date-plugin Sollte das Modul venv nicht installiert sein, muss man das Package python3-venv installieren. Auf Debian/Ubuntu/Raspbian geht das mit dem folgenden Kommando sudo apt install python3-venv","title":"MkDocs Virtual Environment"},{"location":"info/about.html#lokale-erzeugung-der-site","text":"./build","title":"Lokale Erzeugung der Site"},{"location":"info/about.html#veroffentlichung-der-site","text":"F\u00fcr mein GitHub Repository habe ich die GitHub Page https://maroph.github.io/openhpi_linux-cli_2022/ konfiguriert. F\u00fcr diese GitHub Page werden die Daten aus dem Verzeichnis / im Branch gh-pages verwendet. Um diese Page zu aktualisieren, muss man die \u00c4nderungen im lokalen Git Repository committen und in das GitHub Repository pushen: git commit -m \"my commit message\" git push ./build deploy Nach einer relativ kurzen Zeit sind die \u00c4nderungen auf der GitHub Page zu sehen.","title":"Ver\u00f6ffentlichung der Site"},{"location":"info/license.html","text":"Lizenz Die Daten auf dieser Site sind lizenziert unter einer Creative Commons Namensnennung 4.0 International Lizenz . tl;dr: CC-BY 4.0 .","title":"Lizenz"},{"location":"info/license.html#lizenz","text":"Die Daten auf dieser Site sind lizenziert unter einer Creative Commons Namensnennung 4.0 International Lizenz . tl;dr: CC-BY 4.0 .","title":"Lizenz"},{"location":"info/links.html","text":"Links Bash Advanced Bash-Scripting Guide Bash Reference Manual Bash FAQ Bash scripting cheatsheet Pure Bash Bible Rheinwerk Linux SelfLinux Wie man Funktionen in Bash verwendet Linux: Debian 10 Administrationshandbuch Debian mount commando Debian Paketsuche How to Change Colors on LS in Bash How to Mount a USB Drive in Debian How to mount partition with ntfs file system and read write access Introduction to Linux Jobs im Griff mit jobs, bg, fg und & JSLinux Linux im Browser (Chrome, Edge, Firefox, ...) Alpine Linux 3.12 mit einem Kernel 4.12 Linux Manpages: die.net Linux Manpages:man.cx LPIC: Linux Essentials LPIC: LPIC-1 Rechte im Dateisystem RegexLearn Regular-Expressions.info Regular-Expressions.info: Tutorial Regul\u00e4re Ausdr\u00fccke in der Praxis Rheinwerk: Linux - Das umfassende Handbuch Rheinwerk: Wie werde ich UNIX-Guru? snap snapcraft.io Technische Praxis der Computersysteme The TTY demystified Unicode Collation Algorithm Using 'apt search' and 'apt show' Wikipedia: Dateisystem Wikipedia: Inode Wikipedia: Unix-Dateirechte Why are hard links not allowed for directories? Windows-Subsystem f\u00fcr Linux: Dokumentation WSL: Konfiguration der erweiterten Einstellungen in WSL WSL 2 and VPN - get the best route Tools awk User's Guide Crontab: A Beginners Guide To Cron Jobs Cron Ubuntu Wiki crontab guru Crontab Syntax und Tutorial GNU Grep 3.7 grep Cheat Sheet ncat Manpage [ncat User's Guide]( https://nmap.org/ncat/guide/ RegEx 101 Auf dieser Seite kann man interaktiv verschiedene Muster ausprobieren. script Manpage Ein Tool f\u00fcr die Aufzeichnung aller Ein-/Ausgaben in einer Konsole. screen Manpage screen User's Manual sed User's Guide","title":"Links"},{"location":"info/links.html#links","text":"","title":"Links"},{"location":"info/links.html#bash","text":"Advanced Bash-Scripting Guide Bash Reference Manual Bash FAQ Bash scripting cheatsheet Pure Bash Bible Rheinwerk Linux SelfLinux Wie man Funktionen in Bash verwendet","title":"Bash"},{"location":"info/links.html#linux","text":"Debian 10 Administrationshandbuch Debian mount commando Debian Paketsuche How to Change Colors on LS in Bash How to Mount a USB Drive in Debian How to mount partition with ntfs file system and read write access Introduction to Linux Jobs im Griff mit jobs, bg, fg und & JSLinux Linux im Browser (Chrome, Edge, Firefox, ...) Alpine Linux 3.12 mit einem Kernel 4.12 Linux Manpages: die.net Linux Manpages:man.cx LPIC: Linux Essentials LPIC: LPIC-1 Rechte im Dateisystem RegexLearn Regular-Expressions.info Regular-Expressions.info: Tutorial Regul\u00e4re Ausdr\u00fccke in der Praxis Rheinwerk: Linux - Das umfassende Handbuch Rheinwerk: Wie werde ich UNIX-Guru? snap snapcraft.io Technische Praxis der Computersysteme The TTY demystified Unicode Collation Algorithm Using 'apt search' and 'apt show' Wikipedia: Dateisystem Wikipedia: Inode Wikipedia: Unix-Dateirechte Why are hard links not allowed for directories? Windows-Subsystem f\u00fcr Linux: Dokumentation WSL: Konfiguration der erweiterten Einstellungen in WSL WSL 2 and VPN - get the best route","title":"Linux:"},{"location":"info/links.html#tools","text":"awk User's Guide Crontab: A Beginners Guide To Cron Jobs Cron Ubuntu Wiki crontab guru Crontab Syntax und Tutorial GNU Grep 3.7 grep Cheat Sheet ncat Manpage [ncat User's Guide]( https://nmap.org/ncat/guide/ RegEx 101 Auf dieser Seite kann man interaktiv verschiedene Muster ausprobieren. script Manpage Ein Tool f\u00fcr die Aufzeichnung aller Ein-/Ausgaben in einer Konsole. screen Manpage screen User's Manual sed User's Guide","title":"Tools"},{"location":"info/sources.html","text":"Quellenreferenz Diese Site wurde mit MkDocs erstellt. Zus\u00e4tzlich habe ich das Theme Material for MkDocs und das Plugin mkdocs-git-revision-date-plugin verwendet. Das von mir verwendete Linux Logo ist einer verkleinerte Version der Datei \"Linux Logo\" von laboratoriolinux und ist lizenziert unter CC BY-NC-SA 2.0","title":"Quellen"},{"location":"info/sources.html#quellenreferenz","text":"Diese Site wurde mit MkDocs erstellt. Zus\u00e4tzlich habe ich das Theme Material for MkDocs und das Plugin mkdocs-git-revision-date-plugin verwendet. Das von mir verwendete Linux Logo ist einer verkleinerte Version der Datei \"Linux Logo\" von laboratoriolinux und ist lizenziert unter CC BY-NC-SA 2.0","title":"Quellenreferenz"},{"location":"samples/index.html","text":"Beispiele In diesem Bereich gibt es eine Reihe von Beispielen.","title":"Beispiele"},{"location":"samples/index.html#beispiele","text":"In diesem Bereich gibt es eine Reihe von Beispielen.","title":"Beispiele"},{"location":"samples/bash_arrays.html","text":"Bash: Arrays Anlegen eines Arrays Anlegen eines leeren Arrays declare -a array Anlegen eines vorbelegten Arrays declare -a arrayPre =( wert1 wert2 wert3 wert4 ) Werte an ein Array anh\u00e4ngen array +=( \"wert1\" ) array +=( \"wert2\" ) array +=( \"wert3\" ) array +=( \"wert4\" ) Zugriff auf ein Element mit Index Das erste Element in einem Bash Array hat den Index 0. echo \" ${ array [0] } \" echo \" ${ array [1] } \" Einer Wert mit Index setzen array [ 1 ]= \"wert2_neu\" echo \" ${ array [1] } \" array [ 5 ]= \"wert5\" echo \" ${ array [5] } \" Was ist der Wert vom Element mit dem nicht belegtem Index 4 ? echo \" ${ array [4] } \" Da dem Array mit dem Index 4 noch kein Wert zugewiesen wurde, wird der Ausdruck ${array[4]} zu einem Leerstring expandiert L\u00e4nge eines Arrays echo \"L\u00e4nge des Arrays array : ${# array [@] } \" echo \"L\u00e4nge des Arrays arrayPre : ${# arrayPre [@] } \" Array kopieren array2 =( \" ${ array [@] } \" ) Array konkatenieren array3 =( \" ${ array [@] } \" \" ${ array2 [@] } \" ) Teilbereich (von/bis) eines Arrays ausgeben echo \" ${ array [@]: 1 : 4 } \" Es werden die Werte mit dem Index 1-3 ausgegeben. Der erste Wert (1) gibt an, ab welchem Index die Ausgabe bebinnt und der zweite Wert (4) gibt den ersten Index an, dessen Wert nicht mehr ausgegeben werden soll. Ausgabe des gesamten Arrays echo \" ${ array [@] } \" Werte bei der Ausgabe ersetzen echo \" ${ array [@]/wert/value } \" Dieser Ausdruck gibt alle Werte des Array aus. Dabei wird der String \"wert\" durch den String \"value\" ersetzt. Iteration \u00fcber ein Array for wert in \" ${ array [@] } \" do echo \"Wert : ${ wert } \" done Pr\u00fcfen, ob ein Wert im Array enthalten ist if [[ \" ${ array [@] } \" = ~ \" wert1 \" ]] then echo \"der Wert wert1 ist im Array array enthalten\" fi Pr\u00fcfen, ob ein Wert nicht im Array enthalten ist if [[ ! \" ${ array [@] } \" = ~ \" wertNONE \" ]] then echo \"der Wert wertNone ist im Array array NICHT enthalten\" fi L\u00f6schen eines Elementes aus einem Array unset array [ 5 ] L\u00f6schen eines Arrays unset array Zeilenweises Einlesen einer Datei in ein Array Diesen Code habe ich in der BashFAQ/005 im Kapitel \"2.1. Loading lines from a file or stream\" gefunden. mapfile -t array < ./tmp.txt echo \"Anzahl gelesener Zeilen: \\${#array[@]}: ${# array [@] } \" for line in \" ${ array [@] } \" do echo \">>>>> ${ line } \" done Ein Skript, dass alle hier beschriebene Operationen ausf\u00fchrt, findet man hier: bash_arrays.bash","title":"Bash Arrays"},{"location":"samples/bash_arrays.html#bash-arrays","text":"","title":"Bash: Arrays"},{"location":"samples/bash_arrays.html#anlegen-eines-arrays","text":"","title":"Anlegen eines Arrays"},{"location":"samples/bash_arrays.html#anlegen-eines-leeren-arrays","text":"declare -a array","title":"Anlegen eines leeren Arrays"},{"location":"samples/bash_arrays.html#anlegen-eines-vorbelegten-arrays","text":"declare -a arrayPre =( wert1 wert2 wert3 wert4 )","title":"Anlegen eines vorbelegten Arrays"},{"location":"samples/bash_arrays.html#werte-an-ein-array-anhangen","text":"array +=( \"wert1\" ) array +=( \"wert2\" ) array +=( \"wert3\" ) array +=( \"wert4\" )","title":"Werte an ein Array anh\u00e4ngen"},{"location":"samples/bash_arrays.html#zugriff-auf-ein-element-mit-index","text":"Das erste Element in einem Bash Array hat den Index 0. echo \" ${ array [0] } \" echo \" ${ array [1] } \"","title":"Zugriff auf ein Element mit Index"},{"location":"samples/bash_arrays.html#einer-wert-mit-index-setzen","text":"array [ 1 ]= \"wert2_neu\" echo \" ${ array [1] } \" array [ 5 ]= \"wert5\" echo \" ${ array [5] } \" Was ist der Wert vom Element mit dem nicht belegtem Index 4 ? echo \" ${ array [4] } \" Da dem Array mit dem Index 4 noch kein Wert zugewiesen wurde, wird der Ausdruck ${array[4]} zu einem Leerstring expandiert","title":"Einer Wert mit Index setzen"},{"location":"samples/bash_arrays.html#lange-eines-arrays","text":"echo \"L\u00e4nge des Arrays array : ${# array [@] } \" echo \"L\u00e4nge des Arrays arrayPre : ${# arrayPre [@] } \"","title":"L\u00e4nge eines Arrays"},{"location":"samples/bash_arrays.html#array-kopieren","text":"array2 =( \" ${ array [@] } \" )","title":"Array kopieren"},{"location":"samples/bash_arrays.html#array-konkatenieren","text":"array3 =( \" ${ array [@] } \" \" ${ array2 [@] } \" )","title":"Array konkatenieren"},{"location":"samples/bash_arrays.html#teilbereich-vonbis-eines-arrays-ausgeben","text":"echo \" ${ array [@]: 1 : 4 } \" Es werden die Werte mit dem Index 1-3 ausgegeben. Der erste Wert (1) gibt an, ab welchem Index die Ausgabe bebinnt und der zweite Wert (4) gibt den ersten Index an, dessen Wert nicht mehr ausgegeben werden soll.","title":"Teilbereich (von/bis) eines Arrays ausgeben"},{"location":"samples/bash_arrays.html#ausgabe-des-gesamten-arrays","text":"echo \" ${ array [@] } \"","title":"Ausgabe des gesamten Arrays"},{"location":"samples/bash_arrays.html#werte-bei-der-ausgabe-ersetzen","text":"echo \" ${ array [@]/wert/value } \" Dieser Ausdruck gibt alle Werte des Array aus. Dabei wird der String \"wert\" durch den String \"value\" ersetzt.","title":"Werte bei der Ausgabe ersetzen"},{"location":"samples/bash_arrays.html#iteration-uber-ein-array","text":"for wert in \" ${ array [@] } \" do echo \"Wert : ${ wert } \" done","title":"Iteration \u00fcber ein Array"},{"location":"samples/bash_arrays.html#prufen-ob-ein-wert-im-array-enthalten-ist","text":"if [[ \" ${ array [@] } \" = ~ \" wert1 \" ]] then echo \"der Wert wert1 ist im Array array enthalten\" fi","title":"Pr\u00fcfen, ob ein Wert im Array enthalten ist"},{"location":"samples/bash_arrays.html#prufen-ob-ein-wert-nicht-im-array-enthalten-ist","text":"if [[ ! \" ${ array [@] } \" = ~ \" wertNONE \" ]] then echo \"der Wert wertNone ist im Array array NICHT enthalten\" fi","title":"Pr\u00fcfen, ob ein Wert nicht im Array enthalten ist"},{"location":"samples/bash_arrays.html#loschen-eines-elementes-aus-einem-array","text":"unset array [ 5 ]","title":"L\u00f6schen eines Elementes aus einem Array"},{"location":"samples/bash_arrays.html#loschen-eines-arrays","text":"unset array","title":"L\u00f6schen eines Arrays"},{"location":"samples/bash_arrays.html#zeilenweises-einlesen-einer-datei-in-ein-array","text":"Diesen Code habe ich in der BashFAQ/005 im Kapitel \"2.1. Loading lines from a file or stream\" gefunden. mapfile -t array < ./tmp.txt echo \"Anzahl gelesener Zeilen: \\${#array[@]}: ${# array [@] } \" for line in \" ${ array [@] } \" do echo \">>>>> ${ line } \" done Ein Skript, dass alle hier beschriebene Operationen ausf\u00fchrt, findet man hier: bash_arrays.bash","title":"Zeilenweises Einlesen einer Datei in ein Array"},{"location":"samples/bash_assoziative_arrays.html","text":"Bash: Assoziative Arrays Anlegen eines Arrays Anlegen eines leeren Arrays declare -A aArray Anlegen eines vorbelegten Arrays declare -A aArrayPre =( [ key1 ]= val1 [ key2 ]= val2 [ key3 ]= val3 ) Key/Value Paare zu einem Array hinzuf\u00fcgen aArray [ \"key1\" ]= \"value1\" aArray [ \"key2\" ]= \"value2\" Zugriff auf ein Element mit dem Schl\u00fcssel (key) echo \" ${ aArray [ \"key1\" ] } \" echo \" ${ aArray [ \"key2\" ] } \" L\u00e4nge eines Arrays echo \"L\u00e4nge des Arrays aArray : ${# aArray [@] } \" Iteration \u00fcber den Schl\u00fcssel (key) for key in \" ${ !aArray[@] } \" do echo \"key : ${ key } \" echo \"key : ${ key } , value: ${ aArray [ ${ key } ] } \" done Iteration \u00fcber den Wert (value) for value in \" ${ aArray [@] } \" do echo \"value: ${ value } \" done Pr\u00fcfen, ob ein Schl\u00fcssel (key) im Array enthalten ist if [ ${ aArray [key1]+_ } ] then echo \"key1 gefunden\" fi Pr\u00fcfen, ob ein Schl\u00fcssel (key) im Array nicht enthalten ist if [ ! ${ aArray [keyNONE]+_ } ] then echo \"keyNONE nicht gefunden\" fi L\u00f6schen eines Schl\u00fcssels aus einem Array unset aArray [ key1 ] L\u00f6schen eines Arrays unset aArray Ein Skript, dass alle hier beschriebene Operationen ausf\u00fchrt, findet man hier: bash_aArrays.bash","title":"Bash Assoziative Arrays"},{"location":"samples/bash_assoziative_arrays.html#bash-assoziative-arrays","text":"","title":"Bash: Assoziative Arrays"},{"location":"samples/bash_assoziative_arrays.html#anlegen-eines-arrays","text":"","title":"Anlegen eines Arrays"},{"location":"samples/bash_assoziative_arrays.html#anlegen-eines-leeren-arrays","text":"declare -A aArray","title":"Anlegen eines leeren Arrays"},{"location":"samples/bash_assoziative_arrays.html#anlegen-eines-vorbelegten-arrays","text":"declare -A aArrayPre =( [ key1 ]= val1 [ key2 ]= val2 [ key3 ]= val3 )","title":"Anlegen eines vorbelegten Arrays"},{"location":"samples/bash_assoziative_arrays.html#keyvalue-paare-zu-einem-array-hinzufugen","text":"aArray [ \"key1\" ]= \"value1\" aArray [ \"key2\" ]= \"value2\"","title":"Key/Value Paare zu einem Array hinzuf\u00fcgen"},{"location":"samples/bash_assoziative_arrays.html#zugriff-auf-ein-element-mit-dem-schlussel-key","text":"echo \" ${ aArray [ \"key1\" ] } \" echo \" ${ aArray [ \"key2\" ] } \"","title":"Zugriff auf ein Element mit dem Schl\u00fcssel (key)"},{"location":"samples/bash_assoziative_arrays.html#lange-eines-arrays","text":"echo \"L\u00e4nge des Arrays aArray : ${# aArray [@] } \"","title":"L\u00e4nge eines Arrays"},{"location":"samples/bash_assoziative_arrays.html#iteration-uber-den-schlussel-key","text":"for key in \" ${ !aArray[@] } \" do echo \"key : ${ key } \" echo \"key : ${ key } , value: ${ aArray [ ${ key } ] } \" done","title":"Iteration \u00fcber den Schl\u00fcssel (key)"},{"location":"samples/bash_assoziative_arrays.html#iteration-uber-den-wert-value","text":"for value in \" ${ aArray [@] } \" do echo \"value: ${ value } \" done","title":"Iteration \u00fcber den Wert (value)"},{"location":"samples/bash_assoziative_arrays.html#prufen-ob-ein-schlussel-key-im-array-enthalten-ist","text":"if [ ${ aArray [key1]+_ } ] then echo \"key1 gefunden\" fi","title":"Pr\u00fcfen, ob ein Schl\u00fcssel (key) im Array enthalten ist"},{"location":"samples/bash_assoziative_arrays.html#prufen-ob-ein-schlussel-key-im-array-nicht-enthalten-ist","text":"if [ ! ${ aArray [keyNONE]+_ } ] then echo \"keyNONE nicht gefunden\" fi","title":"Pr\u00fcfen, ob ein Schl\u00fcssel (key) im Array nicht enthalten ist"},{"location":"samples/bash_assoziative_arrays.html#loschen-eines-schlussels-aus-einem-array","text":"unset aArray [ key1 ]","title":"L\u00f6schen eines Schl\u00fcssels aus einem Array"},{"location":"samples/bash_assoziative_arrays.html#loschen-eines-arrays","text":"","title":"L\u00f6schen eines Arrays"},{"location":"samples/bash_assoziative_arrays.html#unset-aarray","text":"Ein Skript, dass alle hier beschriebene Operationen ausf\u00fchrt, findet man hier: bash_aArrays.bash","title":"unset aArray\n"},{"location":"samples/bash_functions.html","text":"Bash: Funktionen Werden Bl\u00f6cke von Statements in einem Skript an mehreren Stellen verwendet, ist praktisch, diese Bl\u00f6cke an einer Stelle im Skript zu hinterlegen und dann \u00fcberall dort, wo diese Bl\u00f6cke genutzt werden, auf diese Stelle zu verweisen. In der Bash sind das Funktionen, die man deklariert. Diese Funktionen k\u00f6nnen dann innerhalb eines Skripts aufgerufen werden. Funktionsdeklaration Funktionen k\u00f6nnen auf zwei Arten deklariert werden. Variante 1 function function_name () { statement1 ... statementN } Variante 2 function_name () { statement1 ... statementN } Funktionsdeklaration und Aufruf Hier ein einfaches Besipiel in beiden Varianten function hallo1 () { echo \"Hallo1!\" } hallo1 hallo2 () { echo \"Hallo2!\" } hallo2 Der Aufruf einer Funktion sieht genauso aus wie der Aufruf eines Kommandos/Programms. \u00dcbergabeparameter Parameter werden genau wie bei Kommandos \u00fcbergeben. Im Scope der Funktion kann man f\u00fcr den Zugriff auf die Parameter die Shell Variable $1, ,,, $9, $#, $*, $@ function zeigeUebergabeParameter () { echo \"Anzahl Parameter : $# \" echo \"Parameter 1 : $1 \" echo \"Parameter 2 : $2 \" echo \"Alle Parameter:\" echo \" $@ \" } zeigeUebergabeParameter p1 p2 p3 p4 Anzahl Parameter : 4 Parameter 1 : p1 Parameter 2 : p2 Alle Parameter: p1 p2 p3 p4 Globale/Lokale Variablen Variablen, die au\u00dferhalb einer Funktion deklariert wurden (globale Variablen), k\u00f6nnen auch innerhalb einer Funktion genutzt und ge\u00e4ndert werden. Wird eine Variable in einer Funktion deklariert, ist sie nach dem Aufruf der Funktion auf au\u00dferhald der Funktion deklariert und ist damit auch eine globale Variable. Den G\u00fcltigkeitsbereich einer Variablen kann man auf eine Funktion beschr\u00e4nken, wenn man sie in der Funktion vor einer Variablendeklaration das Schl\u00fcsselwort local setzt. var1 = 1 var2 = 2 # use_of_variables () { local var1 = 10 var2 = 7 var3 = 42 local var4 = 2525 echo \"In der Funktion: var1: $var1 , var2: $var2 , var3: $var3 , var4: $var4 \" } # echo \"Vor dem Aufruf der Funktion: var1: $var1 , var2: $var2 , var3: $var3 , var4: $var4 \" use_of_variables echo \"Nach dem Aufruf der Funktion: var1: $var1 , var2: $var2 , var3: $var3 , var4: $var4 \" Vor dem Aufruf der Funktion: var1: 1, var2: 2, var3: , var4: In der Funktion: var1: 10, var2: 7, var3: 42, var4: 2525 Nach dem Aufruf der Funktion: var1: 1, var2: 7, var3: 42, var4: R\u00fcckgabewert Der R\u00fcckgabewert einer Bash Funktion ist der Exit Code des letzten ausgef\u00fchrten Statements. FULL_SCRIPT_NAME = $0 # function file_size () { stat --format \"%n: %s Bytes\" $1 } file_size ${ FULL_SCRIPT_NAME } echo \"exit code : $? \" echo \"\" file_size diese_datei_gibt_es_nicht echo \"exit code : $? \" echo \"\" Der obige Coder erzeugt die folgende Ausgabe: ./bash_functions.bash: 3314 Bytes exit code : 0 stat: cannot statx 'diese_datei_gibt_es_nicht': No such file or directory exit code : 1 Mit dem Schl\u00fcsselwort return kann man eine Funktion jederzeit beenden und einen Exit Code setzen. FULL_SCRIPT_NAME = $0 # function file_size_return () { return 42 stat --format \"%n: %s Bytes\" $1 } file_size_return ${ FULL_SCRIPT_NAME } echo \"exit code : $? \" Ausgabe: exit code : 42 Ein Skript, dass alle hier gezeigten Beispiele ausf\u00fchrt, findet man hier: bash_functions.bash","title":"Bash Funktionen"},{"location":"samples/bash_functions.html#bash-funktionen","text":"Werden Bl\u00f6cke von Statements in einem Skript an mehreren Stellen verwendet, ist praktisch, diese Bl\u00f6cke an einer Stelle im Skript zu hinterlegen und dann \u00fcberall dort, wo diese Bl\u00f6cke genutzt werden, auf diese Stelle zu verweisen. In der Bash sind das Funktionen, die man deklariert. Diese Funktionen k\u00f6nnen dann innerhalb eines Skripts aufgerufen werden.","title":"Bash: Funktionen"},{"location":"samples/bash_functions.html#funktionsdeklaration","text":"Funktionen k\u00f6nnen auf zwei Arten deklariert werden. Variante 1 function function_name () { statement1 ... statementN } Variante 2 function_name () { statement1 ... statementN }","title":"Funktionsdeklaration"},{"location":"samples/bash_functions.html#funktionsdeklaration-und-aufruf","text":"Hier ein einfaches Besipiel in beiden Varianten function hallo1 () { echo \"Hallo1!\" } hallo1 hallo2 () { echo \"Hallo2!\" } hallo2 Der Aufruf einer Funktion sieht genauso aus wie der Aufruf eines Kommandos/Programms.","title":"Funktionsdeklaration und Aufruf"},{"location":"samples/bash_functions.html#ubergabeparameter","text":"Parameter werden genau wie bei Kommandos \u00fcbergeben. Im Scope der Funktion kann man f\u00fcr den Zugriff auf die Parameter die Shell Variable $1, ,,, $9, $#, $*, $@ function zeigeUebergabeParameter () { echo \"Anzahl Parameter : $# \" echo \"Parameter 1 : $1 \" echo \"Parameter 2 : $2 \" echo \"Alle Parameter:\" echo \" $@ \" } zeigeUebergabeParameter p1 p2 p3 p4 Anzahl Parameter : 4 Parameter 1 : p1 Parameter 2 : p2 Alle Parameter: p1 p2 p3 p4","title":"\u00dcbergabeparameter"},{"location":"samples/bash_functions.html#globalelokale-variablen","text":"Variablen, die au\u00dferhalb einer Funktion deklariert wurden (globale Variablen), k\u00f6nnen auch innerhalb einer Funktion genutzt und ge\u00e4ndert werden. Wird eine Variable in einer Funktion deklariert, ist sie nach dem Aufruf der Funktion auf au\u00dferhald der Funktion deklariert und ist damit auch eine globale Variable. Den G\u00fcltigkeitsbereich einer Variablen kann man auf eine Funktion beschr\u00e4nken, wenn man sie in der Funktion vor einer Variablendeklaration das Schl\u00fcsselwort local setzt. var1 = 1 var2 = 2 # use_of_variables () { local var1 = 10 var2 = 7 var3 = 42 local var4 = 2525 echo \"In der Funktion: var1: $var1 , var2: $var2 , var3: $var3 , var4: $var4 \" } # echo \"Vor dem Aufruf der Funktion: var1: $var1 , var2: $var2 , var3: $var3 , var4: $var4 \" use_of_variables echo \"Nach dem Aufruf der Funktion: var1: $var1 , var2: $var2 , var3: $var3 , var4: $var4 \" Vor dem Aufruf der Funktion: var1: 1, var2: 2, var3: , var4: In der Funktion: var1: 10, var2: 7, var3: 42, var4: 2525 Nach dem Aufruf der Funktion: var1: 1, var2: 7, var3: 42, var4:","title":"Globale/Lokale Variablen"},{"location":"samples/bash_functions.html#ruckgabewert","text":"Der R\u00fcckgabewert einer Bash Funktion ist der Exit Code des letzten ausgef\u00fchrten Statements. FULL_SCRIPT_NAME = $0 # function file_size () { stat --format \"%n: %s Bytes\" $1 } file_size ${ FULL_SCRIPT_NAME } echo \"exit code : $? \" echo \"\" file_size diese_datei_gibt_es_nicht echo \"exit code : $? \" echo \"\" Der obige Coder erzeugt die folgende Ausgabe: ./bash_functions.bash: 3314 Bytes exit code : 0 stat: cannot statx 'diese_datei_gibt_es_nicht': No such file or directory exit code : 1 Mit dem Schl\u00fcsselwort return kann man eine Funktion jederzeit beenden und einen Exit Code setzen. FULL_SCRIPT_NAME = $0 # function file_size_return () { return 42 stat --format \"%n: %s Bytes\" $1 } file_size_return ${ FULL_SCRIPT_NAME } echo \"exit code : $? \" Ausgabe: exit code : 42 Ein Skript, dass alle hier gezeigten Beispiele ausf\u00fchrt, findet man hier: bash_functions.bash","title":"R\u00fcckgabewert"},{"location":"samples/bash_variables.html","text":"Bash: Variablen \u00dcber Bash Variablen gibt es sehr viel zu sagen. Eine kurze \u00dcbericht zu diesem Thema findet man hier: Bash scripting cheatsheet . Ich gebe hier nur einige Beispiele an, die ich des \u00f6fteren verwende. Spezielle Bash Variablen $BASH_VERSION : Version der verwendeten Bash $0 : Dateiname des aufgerufenen Shell Skripts $1, ..., $9 : die ersten 9 Argumente, die an das Shell Skript \u00fcbergeben wurden $# : Anzahl der an ein Skript \u00fcbergebenen Argumente $* : Alle Argumente als ein String (Nutzung: \"$*\") $@ : Alle Argumente als einzelne Strings (Nutzung: \"$@\") $$ : PID (Process Id) des Bash Prozesses $? : Exit Code (errno) des letzten Kommandos Der Exit Code ist eine ganze Zahl im Bereich 0-255. Nur der Wert 0 bedeutet, das kein Fehler aufgetreten ist. $! : PID des zuletzt in der Bash gestarten Hintergrundprozesses $RANDOM : erzeugt bei jedem Zugriff eine neue pseudorandom Zahl im Bereich 0-32767 Die Standard errno Werte sind als C/C++ Makro Definitionen in C/C++ Include Dateien abgelegt und haben die folgende Form: #define ENOENT 2 /* No such file or directory */ Auf einem Debian System findet man diese Makro Definitionen in den Dateien /usr/include/asm-generic/errno-base.h /usr/include/asm-generic/errno.h Welche Exit Codes ein Kommando zur\u00fcckgibt, ist in der Regel in der entsprechenden Manpage beschrieben. Environmentvariablen Shellvariablen sind nur in der aktuelle Shell bekannt. Environmentvariablen dagegen werden an alle Subprozesse der Shell vererbt. Ein Subprozess ist ein Prozess, der von der aktuellen Shell gestartet wurde. Eine Variable wird zu einer Environmentvariablen, indem man sie mit export deklariert: export ENV_VARIABLE = \"Hallo\" Oder auch l\u00e4nger: ENV_VARIABLE = \"Hallo\" export ENV_VARIABLE All derzeit deklarierten Environmentvariablen kann man sich mit dem folgenden Kommando ausgeben lassen: env Beispiel: $ msg = \"Hello\" $ echo \"#!/bin/bash\" >./tmp.bash $ echo \"echo \" msg: \\$ msg \\\" \" >>./tmp.bash $ chmod 700 ./tmp.bash $ ./tmp.bash msg: $ export msg $ ./tmp.bash msg:Hello Variable einen Wert zuweisen und ausgeben msg = \"Hello World!\" echo \" $msg \" L\u00e4nge der Zeichenkette in einer Variablen: ${#msg} echo ${# msg } Variable schreibsch\u00fctzen (readonly) msgr = \"Hello World! #1\" echo \" $msgr \" Hello World! #1 declare -r msgr msgr = \"Hello World! #2\" samples/bash_variables.bash: line 49 : msgr: readonly variable echo \" $msgr \" Hello World! #1 Bilden eines Teilstrings echo \" ${ msg : 0 : 2 } \" Es werden die Werte mit dem Index 0-1 ausgegeben. Der erste Wert (1) gibt an, ab welchem Index die Ausgabe bebinnt und der zweite Wert (2) gibt den ersten Index an, dessen Wert nicht mehr ausgegeben werden soll. Ist Teilstring in einem String enthalten string = 'A long string' if [[ $string == * \"A long\" * ]] then echo \"'A long' is part of the string\" fi string = 'A long string' if [[ $string ! = * \"A short\" * ]] then echo \"'A short' is not part of the string\" fi Ausgabe eines Programms in einer Variablen speichern issue = ` cat /etc/issue ` echo \" $issue \" Ausgabe eines Programms in einer Variablen speichern issue = $( cat /etc/issue ) echo \" $issue \" Erstes Zeichen in einen Gro\u00dfbuchstaben umwandeln echo ${ msg ^ } Alle Kleinbuchstaben in Gro\u00dfbuchstaben umwandeln echo ${ msg ^^ } Alternative Methode: Alle Kleinbuchstaben in Gro\u00dfbuchstaben umwandeln echo $uuid | tr '[:lower:]' '[:upper:]' Erstes Zeichen in einen Kleinbuchstaben umwandeln echo ${ msg , } Alle Gro\u00dfbuchstaben in Kleinbuchstaben umwandeln echo ${ msg ,, } Alternative Methode: Alle Gro\u00dfbuchstaben in Kleinbuchstaben umwandeln echo $msg | tr '[:upper:]' '[:lower:]' Pr\u00fcfen, ob eine Variable eine positive Zahl ohne Vorzeichen + enth\u00e4lt declare -a inp =( a -1 0 +1 1 ) for n in ${ inp [@] } do if ! [[ \" $n \" = ~ ^ [ 1 -9 ][ 0 -9 ] *$ ]] then echo \" $n - keine positive Zahl Zahl ohne Vorzeichen +\" else echo \" $n - positive Zahl Zahl ohne Vorzeichen +\" fi done Wert einer Zahl erh\u00f6hen zahl = 1 echo $zahl zahl = ` expr $zahl + 1 ` echo $zahl echo \"\" Oder: zahl = 1 echo $zahl zahl = $(( zahl + 1 )) echo $zahl echo \"\" Ein Skript, dass alle hier beschriebene Operationen ausf\u00fchrt, findet man hier: bash_variables.bash","title":"Bash Variablen"},{"location":"samples/bash_variables.html#bash-variablen","text":"\u00dcber Bash Variablen gibt es sehr viel zu sagen. Eine kurze \u00dcbericht zu diesem Thema findet man hier: Bash scripting cheatsheet . Ich gebe hier nur einige Beispiele an, die ich des \u00f6fteren verwende.","title":"Bash: Variablen"},{"location":"samples/bash_variables.html#spezielle-bash-variablen","text":"$BASH_VERSION : Version der verwendeten Bash $0 : Dateiname des aufgerufenen Shell Skripts $1, ..., $9 : die ersten 9 Argumente, die an das Shell Skript \u00fcbergeben wurden $# : Anzahl der an ein Skript \u00fcbergebenen Argumente $* : Alle Argumente als ein String (Nutzung: \"$*\") $@ : Alle Argumente als einzelne Strings (Nutzung: \"$@\") $$ : PID (Process Id) des Bash Prozesses $? : Exit Code (errno) des letzten Kommandos Der Exit Code ist eine ganze Zahl im Bereich 0-255. Nur der Wert 0 bedeutet, das kein Fehler aufgetreten ist. $! : PID des zuletzt in der Bash gestarten Hintergrundprozesses $RANDOM : erzeugt bei jedem Zugriff eine neue pseudorandom Zahl im Bereich 0-32767 Die Standard errno Werte sind als C/C++ Makro Definitionen in C/C++ Include Dateien abgelegt und haben die folgende Form: #define ENOENT 2 /* No such file or directory */ Auf einem Debian System findet man diese Makro Definitionen in den Dateien /usr/include/asm-generic/errno-base.h /usr/include/asm-generic/errno.h Welche Exit Codes ein Kommando zur\u00fcckgibt, ist in der Regel in der entsprechenden Manpage beschrieben.","title":"Spezielle Bash Variablen"},{"location":"samples/bash_variables.html#environmentvariablen","text":"Shellvariablen sind nur in der aktuelle Shell bekannt. Environmentvariablen dagegen werden an alle Subprozesse der Shell vererbt. Ein Subprozess ist ein Prozess, der von der aktuellen Shell gestartet wurde. Eine Variable wird zu einer Environmentvariablen, indem man sie mit export deklariert: export ENV_VARIABLE = \"Hallo\" Oder auch l\u00e4nger: ENV_VARIABLE = \"Hallo\" export ENV_VARIABLE All derzeit deklarierten Environmentvariablen kann man sich mit dem folgenden Kommando ausgeben lassen: env Beispiel: $ msg = \"Hello\" $ echo \"#!/bin/bash\" >./tmp.bash $ echo \"echo \" msg: \\$ msg \\\" \" >>./tmp.bash $ chmod 700 ./tmp.bash $ ./tmp.bash msg: $ export msg $ ./tmp.bash msg:Hello","title":"Environmentvariablen"},{"location":"samples/bash_variables.html#variable-einen-wert-zuweisen-und-ausgeben","text":"msg = \"Hello World!\" echo \" $msg \"","title":"Variable einen Wert zuweisen und ausgeben"},{"location":"samples/bash_variables.html#lange-der-zeichenkette-in-einer-variablen-msg","text":"echo ${# msg }","title":"L\u00e4nge der Zeichenkette in einer Variablen: ${#msg}"},{"location":"samples/bash_variables.html#variable-schreibschutzen-readonly","text":"msgr = \"Hello World! #1\" echo \" $msgr \" Hello World! #1 declare -r msgr msgr = \"Hello World! #2\" samples/bash_variables.bash: line 49 : msgr: readonly variable echo \" $msgr \" Hello World! #1","title":"Variable schreibsch\u00fctzen (readonly)"},{"location":"samples/bash_variables.html#bilden-eines-teilstrings","text":"echo \" ${ msg : 0 : 2 } \" Es werden die Werte mit dem Index 0-1 ausgegeben. Der erste Wert (1) gibt an, ab welchem Index die Ausgabe bebinnt und der zweite Wert (2) gibt den ersten Index an, dessen Wert nicht mehr ausgegeben werden soll.","title":"Bilden eines Teilstrings"},{"location":"samples/bash_variables.html#ist-teilstring-in-einem-string-enthalten","text":"string = 'A long string' if [[ $string == * \"A long\" * ]] then echo \"'A long' is part of the string\" fi string = 'A long string' if [[ $string ! = * \"A short\" * ]] then echo \"'A short' is not part of the string\" fi","title":"Ist Teilstring in einem String enthalten"},{"location":"samples/bash_variables.html#ausgabe-eines-programms-in-einer-variablen-speichern","text":"issue = ` cat /etc/issue ` echo \" $issue \"","title":"Ausgabe eines Programms in einer Variablen speichern"},{"location":"samples/bash_variables.html#ausgabe-eines-programms-in-einer-variablen-speichern_1","text":"issue = $( cat /etc/issue ) echo \" $issue \"","title":"Ausgabe eines Programms in einer Variablen speichern"},{"location":"samples/bash_variables.html#erstes-zeichen-in-einen-grobuchstaben-umwandeln","text":"echo ${ msg ^ }","title":"Erstes Zeichen in einen Gro\u00dfbuchstaben umwandeln"},{"location":"samples/bash_variables.html#alle-kleinbuchstaben-in-grobuchstaben-umwandeln","text":"echo ${ msg ^^ }","title":"Alle Kleinbuchstaben in Gro\u00dfbuchstaben umwandeln"},{"location":"samples/bash_variables.html#alternative-methode-alle-kleinbuchstaben-in-grobuchstaben-umwandeln","text":"echo $uuid | tr '[:lower:]' '[:upper:]'","title":"Alternative Methode: Alle Kleinbuchstaben in Gro\u00dfbuchstaben umwandeln"},{"location":"samples/bash_variables.html#erstes-zeichen-in-einen-kleinbuchstaben-umwandeln","text":"echo ${ msg , }","title":"Erstes Zeichen in einen Kleinbuchstaben umwandeln"},{"location":"samples/bash_variables.html#alle-grobuchstaben-in-kleinbuchstaben-umwandeln","text":"echo ${ msg ,, }","title":"Alle Gro\u00dfbuchstaben in Kleinbuchstaben umwandeln"},{"location":"samples/bash_variables.html#alternative-methode-alle-grobuchstaben-in-kleinbuchstaben-umwandeln","text":"echo $msg | tr '[:upper:]' '[:lower:]'","title":"Alternative Methode: Alle Gro\u00dfbuchstaben in Kleinbuchstaben umwandeln"},{"location":"samples/bash_variables.html#prufen-ob-eine-variable-eine-positive-zahl-ohne-vorzeichen-enthalt","text":"declare -a inp =( a -1 0 +1 1 ) for n in ${ inp [@] } do if ! [[ \" $n \" = ~ ^ [ 1 -9 ][ 0 -9 ] *$ ]] then echo \" $n - keine positive Zahl Zahl ohne Vorzeichen +\" else echo \" $n - positive Zahl Zahl ohne Vorzeichen +\" fi done","title":"Pr\u00fcfen, ob eine Variable eine positive Zahl ohne Vorzeichen + enth\u00e4lt"},{"location":"samples/bash_variables.html#wert-einer-zahl-erhohen","text":"zahl = 1 echo $zahl zahl = ` expr $zahl + 1 ` echo $zahl echo \"\" Oder: zahl = 1 echo $zahl zahl = $(( zahl + 1 )) echo $zahl echo \"\" Ein Skript, dass alle hier beschriebene Operationen ausf\u00fchrt, findet man hier: bash_variables.bash","title":"Wert einer Zahl erh\u00f6hen"},{"location":"samples/date_samples.html","text":"Beispiele f\u00fcr das Kommando date Einfacher Zeitstempel f\u00fcr Logdateien und tempor\u00e4re Dateien Ausgabeformat: YYYYMMDDhhmmss date + \"%Y%m%d%H%M%S\" 20220205171709 RFC3339 Zeitstempelformat erzeugen RFC3339: Date and Time on the Internet: Timestamps date + \"%Y-%m-%dT%H:%M:%S%:z\" 2022 -02-05T17:17:09+01:00 Ausgabe in UTC Zeit date --utc + \"%Y-%m-%dT%H:%M:%S%:z\" 2022 -02-05T16:17:09+00:00 ISO 8601 Zeitstempelformat erzeugen date + \"%Y-%m-%dT%H:%M:%S%z\" 2022 -02-05T17:17:09+0100 D.h: der einzige Unterschied ist der Doppelpunkt (:) in der Zeitzonenangabe. Das RFC3339 Format ist aber auch ein g\u00fcltiges ISO 8601 Format. Weitere Details findet man hier: RFC 3339 vs ISO 8601 . Sekunden seit dem 01.01.1970, 00:00:00 Uhr UTC-Zeit In Linux wird die Zeit intern in Sekunden (oder auch Milli- bzw. Nanosekunden) seit dem 01.01.1970 um 00:00:00 Uhr UTC Zeit berechnet. In vielen Logdateien wird dieser Wert als Zeitstempel benutzt. Mit dme date Kommando kann man sich diesen Wert ausgeben lassen: date +%s 1644077829 Sekunden seit dem 01.01.1970, 00:00:00 Uhr UTC-Zeit in Datum umwandeln Findet man in einer Logdatei so einen Zeitstempel, kann man ihn mit dem date Kommando einfach in ein Datum samt Uhrzeit. Zuerst holen wir uns einen Zeitstempel (um Beispiel die aktuelle Zeit) now = $( date +%s ) echo \" ${ now } \" 1644077829 Diesen Zeitstempel kann man folgenderma\u00dfen im date Kommando nutzen date --date = @ ${ now } Sat 05 Feb 2022 05 :17:09 PM CET Zus\u00e4tzlich kann man auch ein Ausgabeformat angeben (hier das RFC3339 Format) date --date = @ ${ now } + \"%Y-%m-%dT%H:%M:%S%:z\" 2022 -02-05T17:17:09+01:00 Alternativ kann man auch eine Ausgabe in der UTC Zeit erhalten date --utc --date = @ ${ now } + \"%Y-%m-%dT%H:%M:%S%:z\" 2022 -02-05T16:17:09+00:00 Git: Letzten commit Zeitstempel f\u00fcr eine Datei ausgeben Den Zeitstempel, in Sekunden seit dem 01.01.1970, 00:00:00 Uhr UTC-Zeit, erh\u00e4lt man folgenderma\u00dfen: git log -1 --format = %ct docs-src/samples/date_samples.md 1644230639 Das zugeh\u00f6rige Datum kann man dann so ausgeben: date --date = @1644230639 Mon 07 Feb 2022 11 :43:59 AM CET Hier noch der Zeitstempel im RFC3339 Format: date --date = @1644230639 + \"%Y-%m-%dT%H:%M:%S%:z\" 2022 -02-07T11:43:59+01:00 Ein Skript, dass alle hier beschriebene Operationen ausf\u00fchrt, findet man hier: date_samples.bash","title":"date Kommando"},{"location":"samples/date_samples.html#beispiele-fur-das-kommando-date","text":"","title":"Beispiele f\u00fcr das Kommando date"},{"location":"samples/date_samples.html#einfacher-zeitstempel-fur-logdateien-und-temporare-dateien","text":"Ausgabeformat: YYYYMMDDhhmmss date + \"%Y%m%d%H%M%S\" 20220205171709","title":"Einfacher Zeitstempel f\u00fcr Logdateien und tempor\u00e4re Dateien"},{"location":"samples/date_samples.html#rfc3339-zeitstempelformat-erzeugen","text":"RFC3339: Date and Time on the Internet: Timestamps date + \"%Y-%m-%dT%H:%M:%S%:z\" 2022 -02-05T17:17:09+01:00","title":"RFC3339 Zeitstempelformat erzeugen"},{"location":"samples/date_samples.html#ausgabe-in-utc-zeit","text":"date --utc + \"%Y-%m-%dT%H:%M:%S%:z\" 2022 -02-05T16:17:09+00:00","title":"Ausgabe in UTC Zeit"},{"location":"samples/date_samples.html#iso-8601-zeitstempelformat-erzeugen","text":"date + \"%Y-%m-%dT%H:%M:%S%z\" 2022 -02-05T17:17:09+0100 D.h: der einzige Unterschied ist der Doppelpunkt (:) in der Zeitzonenangabe. Das RFC3339 Format ist aber auch ein g\u00fcltiges ISO 8601 Format. Weitere Details findet man hier: RFC 3339 vs ISO 8601 .","title":"ISO 8601 Zeitstempelformat erzeugen"},{"location":"samples/date_samples.html#sekunden-seit-dem-01011970-000000-uhr-utc-zeit","text":"In Linux wird die Zeit intern in Sekunden (oder auch Milli- bzw. Nanosekunden) seit dem 01.01.1970 um 00:00:00 Uhr UTC Zeit berechnet. In vielen Logdateien wird dieser Wert als Zeitstempel benutzt. Mit dme date Kommando kann man sich diesen Wert ausgeben lassen: date +%s 1644077829","title":"Sekunden seit dem 01.01.1970, 00:00:00 Uhr UTC-Zeit"},{"location":"samples/date_samples.html#sekunden-seit-dem-01011970-000000-uhr-utc-zeit-in-datum-umwandeln","text":"Findet man in einer Logdatei so einen Zeitstempel, kann man ihn mit dem date Kommando einfach in ein Datum samt Uhrzeit. Zuerst holen wir uns einen Zeitstempel (um Beispiel die aktuelle Zeit) now = $( date +%s ) echo \" ${ now } \" 1644077829 Diesen Zeitstempel kann man folgenderma\u00dfen im date Kommando nutzen date --date = @ ${ now } Sat 05 Feb 2022 05 :17:09 PM CET Zus\u00e4tzlich kann man auch ein Ausgabeformat angeben (hier das RFC3339 Format) date --date = @ ${ now } + \"%Y-%m-%dT%H:%M:%S%:z\" 2022 -02-05T17:17:09+01:00 Alternativ kann man auch eine Ausgabe in der UTC Zeit erhalten date --utc --date = @ ${ now } + \"%Y-%m-%dT%H:%M:%S%:z\" 2022 -02-05T16:17:09+00:00","title":"Sekunden seit dem 01.01.1970, 00:00:00 Uhr UTC-Zeit in Datum umwandeln"},{"location":"samples/date_samples.html#git-letzten-commit-zeitstempel-fur-eine-datei-ausgeben","text":"Den Zeitstempel, in Sekunden seit dem 01.01.1970, 00:00:00 Uhr UTC-Zeit, erh\u00e4lt man folgenderma\u00dfen: git log -1 --format = %ct docs-src/samples/date_samples.md 1644230639 Das zugeh\u00f6rige Datum kann man dann so ausgeben: date --date = @1644230639 Mon 07 Feb 2022 11 :43:59 AM CET Hier noch der Zeitstempel im RFC3339 Format: date --date = @1644230639 + \"%Y-%m-%dT%H:%M:%S%:z\" 2022 -02-07T11:43:59+01:00 Ein Skript, dass alle hier beschriebene Operationen ausf\u00fchrt, findet man hier: date_samples.bash","title":"Git: Letzten commit Zeitstempel f\u00fcr eine Datei ausgeben"},{"location":"samples/misc.html","text":"Verschiedenes Shell Zen zen.bash ist ein kleines Skript zur Entspannung. Wesentlicher Teil des Skripts ist eine Schleife: count = 0 maxcount = 10 while [ ${ count } -lt ${ maxcount } ] do ... count = $(( count + 1 )) done Ablauf: so lange die Variable count kleiner als die Variable maxcount ist, wird die Schleife durchlaufen. Am Ende der Schleife wird der Wert der Variablen count um 1 vergr\u00f6\u00dfert. Passwort pr\u00fcfen Basierend auf dem heise Artikel Nach dem Passwort-Leak: Eigene Passw\u00f6rter lokal checken habe ich mir das Skript checkPassword.bash geschrieben. Das Skript pr\u00fcft, ob das angegebene Passwort in der Pwned Passwords Datenbank enthalten ist. Man kann das Passwort auch auf der Site angeben, aber es wird dann auch an die Site \u00fcbertragen. Beispiel f\u00fcr eine Abfrage der Daten Wie man diese Datenbank nutzen kann, ohne das Passwort an die Site zu \u00fcbertragen, ist im heise Artikel beschrieben. Im folgenden Beispiel wird das Passwort 123456 benutzt. Zuerst bildet man den SHA1 (Secure Hash Algorithm 1) Wert des Pasworts: $ echo -n \"123456\" | sha1sum 7c4a8d09ca3762af61e59520943dc26494f8941b - Warum wird echo mit -n aufgerufen? echo \"123456\" | sha1sum c4f9375f9834b4e7f0a528cc65c055702bf5f24a - D.h.: man erh\u00e4lt einen anderen Hashwert. $ echo -n \"123456\" | xxd 00000000 : 3132 3334 3536 123456 $ echo \"123456\" | xxd 00000000 : 3132 3334 3536 0a 123456 . Der Aufruf echo h\u00e4ngt an das Ende der Zeichenkette noch das Steuerzeichen 0x0a an, das f\u00fcr einen Zeilenvorschub sorgt. Da aber nur die Zeichenkette selbst gehasht werden soll, muss man echo mit der Option -n aufrufen. Am Ende der Ausgabe des Hashwerts steht nach dem Hashwert noch \" -\". Diesen Teil kann man folgenderma\u00dfen entfernen: $ echo -n \"123456\" | sha1sum | awk '{ print $1; }' 7c4a8d09ca3762af61e59520943dc26494f8941b Das awk Kommando bewirkt, dass von jeder gelesen Zeile (hier nur eine Zeile) das erste Wort ausgegeben wird. Soweit so gut, aber: der Suchstring f\u00fcr die Abfrage muss Gro\u00dfuchstaben statt Kleinbuchstaben enthalten. $ echo -n \"123456\" | sha1sum | awk '{ print $1; }' | tr '[a-z]' '[A-Z]' 7C4A8D09CA3762AF61E59520943DC26494F8941B Man kann hier auch das folgende verwenden: $ echo -n \"123456\" | sha1sum | awk '{ print $1; }' | tr '[:lower:]' '[:upper:]' 7C4A8D09CA3762AF61E59520943DC26494F8941B F\u00fcr die Suche werden nur die ersten 5 Zeichen (\"7C4A8\") gesendet. Dazu ruft man mit einem HTTP Get Request die folgende URL auf: https://api.pwnedpasswords.com/range/7C4A8 Als Ergebnis erh\u00e4lt man eine Liste von Hashwerten (ohne die ersten 5 Zeichen) und die Anzahl der Treffer in der Datenbank. Die Zeilen haben dabei das folgende Format: : F\u00fcr das Passwort 123456 sieht die Zeile folgenderma\u00dfen aus: D09CA3762AF61E59520943DC26494F8941B:37359195 Die ben\u00f6tigten Wert kann man sich in der Bash folgenderma\u00dfen in Variablen speichern: hash = ` echo -n ${ password } | sha1sum | awk '{ print $1; }' | tr '[a-z]' '[A-Z]' ` # # benutze die ersten 5 Zeichen f\u00fcr die Suche lookup = ${ hash : 0 : 5 } # # benutze den Rest als Suchstring in der erhaltenen Liste rest = ${ hash : 5 } Der HTTP Get Request kann in der Shell folgenderma\u00dfen erzeugt werden: curl --tlsv1.3 --silent -o ./checkPassword.bash.txt https://api.pwnedpasswords.com/range/7C4A8 Hier die Bedeutung der verwendeten curl Optionen: --tlsv1.3 : verwende das TLS 1.3 Protokoll --silent : curl soll keine unn\u00f6tigen Ausgaben machen -o dateiname : schreibe die Antwort vom GET Request ind die Datei dateiname Die erhaltenen Daten werden in der ./checkPassword.bash.txt gespeichert. Zuerst wird dann gepr\u00fcft, ob es den vom Passwort gebildet Resthash in der Datei gibt. Ist der Exit Code der grep Suche ungleich 0, gabe es keinen Treffer. Gibt es einen Treffer, wird die Trefferanzahl mit einem sed Aufruf aus der Zeile herausgeholt. grep ${ rest } ./checkPassword.bash.txt >/dev/null if [ $? -ne 0 ] then echo \"./checkPassword.bash.: password not found\" else echo -n \"./checkPassword.bash: number of hits : \" grep ${ rest } ./checkPassword.bash.txt | sed -e 's/^.*://' fi Bespielaufrufe $ ./checkPassword.bash 123456 checkPassword.bash: number of hits : 37359195 $ ./checkPassword.bash geheim checkPassword.bash: number of hits : 46130 $ ./checkPassword.bash secret checkPassword.bash: number of hits : 352091 $ ./checkPassword.bash DasSuperGeheimePassword checkPassword.bash: password not found","title":"Verschiedenes"},{"location":"samples/misc.html#verschiedenes","text":"","title":"Verschiedenes"},{"location":"samples/misc.html#shell-zen","text":"zen.bash ist ein kleines Skript zur Entspannung. Wesentlicher Teil des Skripts ist eine Schleife: count = 0 maxcount = 10 while [ ${ count } -lt ${ maxcount } ] do ... count = $(( count + 1 )) done Ablauf: so lange die Variable count kleiner als die Variable maxcount ist, wird die Schleife durchlaufen. Am Ende der Schleife wird der Wert der Variablen count um 1 vergr\u00f6\u00dfert.","title":"Shell Zen"},{"location":"samples/misc.html#passwort-prufen","text":"Basierend auf dem heise Artikel Nach dem Passwort-Leak: Eigene Passw\u00f6rter lokal checken habe ich mir das Skript checkPassword.bash geschrieben. Das Skript pr\u00fcft, ob das angegebene Passwort in der Pwned Passwords Datenbank enthalten ist. Man kann das Passwort auch auf der Site angeben, aber es wird dann auch an die Site \u00fcbertragen.","title":"Passwort pr\u00fcfen"},{"location":"samples/misc.html#beispiel-fur-eine-abfrage-der-daten","text":"Wie man diese Datenbank nutzen kann, ohne das Passwort an die Site zu \u00fcbertragen, ist im heise Artikel beschrieben. Im folgenden Beispiel wird das Passwort 123456 benutzt. Zuerst bildet man den SHA1 (Secure Hash Algorithm 1) Wert des Pasworts: $ echo -n \"123456\" | sha1sum 7c4a8d09ca3762af61e59520943dc26494f8941b - Warum wird echo mit -n aufgerufen? echo \"123456\" | sha1sum c4f9375f9834b4e7f0a528cc65c055702bf5f24a - D.h.: man erh\u00e4lt einen anderen Hashwert. $ echo -n \"123456\" | xxd 00000000 : 3132 3334 3536 123456 $ echo \"123456\" | xxd 00000000 : 3132 3334 3536 0a 123456 . Der Aufruf echo h\u00e4ngt an das Ende der Zeichenkette noch das Steuerzeichen 0x0a an, das f\u00fcr einen Zeilenvorschub sorgt. Da aber nur die Zeichenkette selbst gehasht werden soll, muss man echo mit der Option -n aufrufen. Am Ende der Ausgabe des Hashwerts steht nach dem Hashwert noch \" -\". Diesen Teil kann man folgenderma\u00dfen entfernen: $ echo -n \"123456\" | sha1sum | awk '{ print $1; }' 7c4a8d09ca3762af61e59520943dc26494f8941b Das awk Kommando bewirkt, dass von jeder gelesen Zeile (hier nur eine Zeile) das erste Wort ausgegeben wird. Soweit so gut, aber: der Suchstring f\u00fcr die Abfrage muss Gro\u00dfuchstaben statt Kleinbuchstaben enthalten. $ echo -n \"123456\" | sha1sum | awk '{ print $1; }' | tr '[a-z]' '[A-Z]' 7C4A8D09CA3762AF61E59520943DC26494F8941B Man kann hier auch das folgende verwenden: $ echo -n \"123456\" | sha1sum | awk '{ print $1; }' | tr '[:lower:]' '[:upper:]' 7C4A8D09CA3762AF61E59520943DC26494F8941B F\u00fcr die Suche werden nur die ersten 5 Zeichen (\"7C4A8\") gesendet. Dazu ruft man mit einem HTTP Get Request die folgende URL auf: https://api.pwnedpasswords.com/range/7C4A8 Als Ergebnis erh\u00e4lt man eine Liste von Hashwerten (ohne die ersten 5 Zeichen) und die Anzahl der Treffer in der Datenbank. Die Zeilen haben dabei das folgende Format: : F\u00fcr das Passwort 123456 sieht die Zeile folgenderma\u00dfen aus: D09CA3762AF61E59520943DC26494F8941B:37359195 Die ben\u00f6tigten Wert kann man sich in der Bash folgenderma\u00dfen in Variablen speichern: hash = ` echo -n ${ password } | sha1sum | awk '{ print $1; }' | tr '[a-z]' '[A-Z]' ` # # benutze die ersten 5 Zeichen f\u00fcr die Suche lookup = ${ hash : 0 : 5 } # # benutze den Rest als Suchstring in der erhaltenen Liste rest = ${ hash : 5 } Der HTTP Get Request kann in der Shell folgenderma\u00dfen erzeugt werden: curl --tlsv1.3 --silent -o ./checkPassword.bash.txt https://api.pwnedpasswords.com/range/7C4A8 Hier die Bedeutung der verwendeten curl Optionen: --tlsv1.3 : verwende das TLS 1.3 Protokoll --silent : curl soll keine unn\u00f6tigen Ausgaben machen -o dateiname : schreibe die Antwort vom GET Request ind die Datei dateiname Die erhaltenen Daten werden in der ./checkPassword.bash.txt gespeichert. Zuerst wird dann gepr\u00fcft, ob es den vom Passwort gebildet Resthash in der Datei gibt. Ist der Exit Code der grep Suche ungleich 0, gabe es keinen Treffer. Gibt es einen Treffer, wird die Trefferanzahl mit einem sed Aufruf aus der Zeile herausgeholt. grep ${ rest } ./checkPassword.bash.txt >/dev/null if [ $? -ne 0 ] then echo \"./checkPassword.bash.: password not found\" else echo -n \"./checkPassword.bash: number of hits : \" grep ${ rest } ./checkPassword.bash.txt | sed -e 's/^.*://' fi","title":"Beispiel f\u00fcr eine Abfrage der Daten"},{"location":"samples/misc.html#bespielaufrufe","text":"$ ./checkPassword.bash 123456 checkPassword.bash: number of hits : 37359195 $ ./checkPassword.bash geheim checkPassword.bash: number of hits : 46130 $ ./checkPassword.bash secret checkPassword.bash: number of hits : 352091 $ ./checkPassword.bash DasSuperGeheimePassword checkPassword.bash: password not found","title":"Bespielaufrufe"},{"location":"woche/index.html","text":"Woche Der Kurs ist auf 2 Kurswochen ausgelegt. Zu jeder Woche habe ich einige Notizen in diesem Bereich abgelegt. Hinweis: alle Beispiele benutzen die Bash als Shell. En abweichendes Verhalten in anderen Shells ist deshalb m\u00f6glich.","title":"Woche"},{"location":"woche/index.html#woche","text":"Der Kurs ist auf 2 Kurswochen ausgelegt. Zu jeder Woche habe ich einige Notizen in diesem Bereich abgelegt. Hinweis: alle Beispiele benutzen die Bash als Shell. En abweichendes Verhalten in anderen Shells ist deshalb m\u00f6glich.","title":"Woche"},{"location":"woche/woche1.html","text":"Woche 1 Themen der Woche 1 Was ist Linux und was ist Unix? Was bedeuten die Begriffe Terminal, Shell, Terminalemulator und Konsole? Wie findet man sich in der Kommandozeile zurecht? Wie ist ein Kommando aufgebaut? Welche sind die wichtigsten Kommandos? GUI Desktop Tastenkombinationen Strg + C Strg + D Strg + Shift + C in das Clipboard kopieren Strg + Shift + V aus dem Clipboard einf\u00fcgen Strg + L Bildschirm leeren Strg + Alt/Shift + T Terminalfenster \u00f6ffnen (Alt oder Shift sollte funktionieren) Tab automatische Vervollst\u00e4ndigung Pfeiltasten oben/unten zuletzt benutze Befehle man <befehl> \u00f6ffnet das Manual f\u00fcr den entsprechenden Befehl Beispiel f\u00fcr eine Package Installation Das Programm sl (steam locomotive - Dampflokomotive) wird folgenderma\u00dfen installiert. sudo apt install sl Ruft man dann sl auf /usr/games/sl sieht man eine Lokomotive \u00fcber den Bildschirm fahren: Hinweis: in der Regel ist das Verzeichnis /usr/games nicht im Suchpfad der Shell. Will man nur den Programmnamen ohne Pfad beim Aufruf angeben, gibt es zwei M\u00f6glichkeiten: Den Suchpfad der Shell erweitern: PATH=$PATH:/usr/games Ein alias f\u00fcr das Programm anlegen alias sl='/usr/games/sl' Debian Paktetverwaltung Wei\u00df man nicht genau, in welchem Debian Paket ein Programm enthalten ist, kann man das Pakte mit Hilfe der Debian-Paketsuche Warum gibt es die Eintr\u00e4ge . und .. in einem Verzeichnis? In jedem Verzeichnis gibt es die beiden Eintr\u00e4ge . und .. : . verweist auf das aktuelle Verzeichnis cd . : es \u00e4ndert sich nicht, ich befinde mich immer noch im gleichen Verzeichnis .. verweist auf das \u00fcbergeordnete Verzeichnis (parent directory) cd .. : ich wechsele in das \u00fcbergeordnete Verzeichnis Verzeichniseintrag .. Angenommen ich befinde mich derzeit im Verzeichnis /home/openhpi/linux_cli und gebe dort die folgenden Kommandos ein ($ ist das Prompt (Eingabeaufforderung) der Shell. Die Zeichen nach dem $ sind die Eingaben, die Zeilen ohne $ am Anfang sind die Ausgaben) $ pwd /home/openhpi/linux_cli $ find week1-dir -type d -print week1-dir week1-dir/dir3 week1-dir/dir2 week1-dir/dir2/.hidden week1-dir/dir1 $ cd week1-dir/dir1 $ pwd /home/openhpi/linux_cli/week1-dir/dir1 Jetzt m\u00f6chte ich in das Verzeichnis /home/openhpi/linux_cli/week1-dir . Die folgenden cd Kommandos kann man dazu nicht verwenden. $ cd - : wechsele zur\u00fcck in das letzte Verzeichnis (_/home/openhpi/linux_cli_) $ cd : wechsele in das Homeverzeichnis der Kennung (_/home/openhpi_) D.h. ich muss das folgende eingeben: $ cd /home/openhpi/linux_cli/week1-dir Mit Hilfe des Verzeichniseintrags .. kann ich aber kurz schreiben $ cd .. Vorteil: erstens ist diese Schreibweise k\u00fcrzer - aber viel wichtiger: ich brauche dabei den Namen des Verzeichnisses, in das ich wechseln will, nicht kennen. Kuriose Ausnahme Das Rootverzeichnis / eines Dateisystems enth\u00e4lt auch die Eintr\u00e4ge . und .. In diesem Fall verweisen sowohl . als auch .. auf / Verzeichniseintrag . Der nutzen von .. sollte einigerma\u00dfen klar sein. Frage: warum braucht man den Eintrag . ? Beispiel: in meinem aktuellen Verzeichnis gibt es die ausf\u00fchrbare Datei hallo, die beider Ausf\u00fchrung Hallo ausgibt. Wenn ich den Namen einfach als Kommando in die Shell eingebe, passiert das Folgende: $ hallo -bash: hallo: command not found Warum ist das so? Die Shell interpretiert hallo als auszuf\u00fchrendes Kommando. Das es kein in die Shell eingebautes Kommando ist, muss sie wissen, wo im Dateisystem die Datei zu finden ist. Dazu benutzt die Shell die Variable PATH $ echo $PATH /usr/local/bin:/usr/bin:/bin Hier kann man mehrere durch : getrennte Verzeichnisse angeben. Im obigen Beispiel w\u00fcrde die Shell in der folgenden Reihenfolge nach der Datei hallo suchen: /usr/local/bin/hallo /usr/bin/hallo /bin/hallo Dabei gilt: der erste Treffer wird ausgef\u00fchrt. Man kann nat\u00fcrlich das akutelle Verzeichnis, in dem man sich befindet, zur Variabeln PATH hinzuf\u00fcgen: $ PATH = \" $PATH : $( pwd ) \" Aber das ist nat\u00fcrlich nicht immer sinnvoll. Will man wissen, wo im Pfad ($PATH) das Kommando gefunden wurde, kann man das Kommando type nutzen: $ type ls ls is hashed ( /bin/ls ) N\u00e4chster Versuch: $ bash hallo Hallo Sieht gut aus, es kann aber auch das Folgende passieren: bash hallo hallo: hallo: cannot execute binary file Warum? Beim Aufruf $ bash hallo erwartet die Bash, das die Datei hallo ein Bash Skript enth\u00e4lt. Von welchem Typ meine ausf\u00fchrbare Datei ist (Shell Skript oder Programm), sieht man mit dem folgenden Kommando: $ file hallo hallo: Bourne-Again shell script, ASCII text executable $ file hallo hallo: ELF 64 -bit LSB pie executable, x86-64, version 1 ( SYSV ) , dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID [ sha1 ]= 1dc10461ed0684ca195d2712ba9a0205d2989543, for GNU/Linux 3 .2.0, not stripped Ohne den Typ zu kennen, m\u00fcsste man das Skript/Programm folgenderma\u00dfen aufrufen: $ /home/openhpi/linux_cli/week1-dir/dir1/hallo Hallo Mit Hilfe des builtin Kommandos pwd in der Shell geht das auch so: $ $( pwd ) /hallo Hallo Da . auf das aktuelle Verzeichnis verweist, kann man aber auch einfach das Folgende aufrufen: $ ./hallo Hallo Sollen immer alle ausf\u00fchrbaren Dateien im aktuellen Verzeichnis von der Shell gefunden werden, kann man die Variable PATH folgenderma\u00dfen erweitern: $ PATH = \" $PATH :.\" Bleibt noch die Frage, warum $ ./hallo als Bash Skript ausgef\u00fchrt wird. L\u00f6sung: die Datei Datei sieht folgenderma\u00dfen aus: $ cat hallo #!/bin/bash # echo \"Hallo\" Wichtig ist hierbei die erste Zeile: #!/bin/bash Diese Zeile wird als Shebang bezeichnet. Die Shell nimmt in diesem Fall an, dass die Zeichenkette nach \"#!\" ein Kommando ist. Die Shell ruft dieses Kommando auf und \u00fcbergibt den Rest der Datei an das Kommando. Weitere Informationen Wikipedia: Dateisystem Wikipedia: Inode Daten f\u00fcr die Praktische \u00dcbung 1.9 Die Daten f\u00fcr die Praktische \u00dcbung 1.9 habe ich hier abgelegt: week1-dir/ Ausgepacktes Archiv week1-dir.tar.gz TAR Datei der Daten week1-dir.zip Die original ZIP Datei Auspacken der TAR Datei: tar xvf week1-dir.tar.gz finden. Zusammenfassung der Woche 1 Linux verwendet, \u00e4hnlich wie Windows, ein Dateisystem mit Verzeichnissen und Dateien. Loggt man sich and der Console ein, oder \u00f6ffnet in einer GUI ein Terminalfenster befindet man sich im sogenannten Homeverzeichnis der Kennung. Das Verzeichnis, in dem man sich gerade befindet, kann man sich mit dem Kommando pwd ansehen: $ pwd /home/openhpi Mit dem Kommando cd kann man das Verzeichnis wechseln. $ cd linux_cli $ pwd /home/openhpi/linux_cli Es gibt 3 spezielle M\u00f6glichkeiten, das Kommando cd zu nutzen: cd : wechsel in das Homeverzeichnis cd ~ : wechsel in das Homeverzeichnis cd - : wechsel in das letzte Verzeichnis Beispiel: $ pwd /home/openhpi $ cd linux_cli $ pwd /home/openhpi/linux_cli $ cd $ pwd /home/openhpi $ cd linux_cli $ pwd /home/openhpi/linux_cli $ cd ~ $ pwd /home/openhpi $ cd linux_cli $ pwd /home/openhpi/linux_cli $ cd week1-dir $ pwd /home/openhpi/linux_cli/week1-dir $ cd - /home/openhpi/linux_cli $ pwd /home/openhpi/linux_cli Die in einem Verzeichns vorhandenen Verzeichnisse/Dateien kann man sich mit dem Kommando ls ansehen. In Linux gibt es eine Reihe von Rechte im Dateisystem . Diese Rechte kann man mit dem Kommando chmod ver\u00e4ndern. Zur Installation von Programmen ben\u00f6tigt man eine Administratorberechtigung. In einer Desktop Linux Umgebung ist in der Regle mindestens ein Benutzer so konfiguriert, dass er das Programm sudo aufrufen kann. Dieser Benutzer kann das Software auf dem Rechner installieren. Beispiel: sudo apt install fortune","title":"Woche1"},{"location":"woche/woche1.html#woche-1","text":"Themen der Woche 1 Was ist Linux und was ist Unix? Was bedeuten die Begriffe Terminal, Shell, Terminalemulator und Konsole? Wie findet man sich in der Kommandozeile zurecht? Wie ist ein Kommando aufgebaut? Welche sind die wichtigsten Kommandos?","title":"Woche 1"},{"location":"woche/woche1.html#gui-desktop-tastenkombinationen","text":"Strg + C Strg + D Strg + Shift + C in das Clipboard kopieren Strg + Shift + V aus dem Clipboard einf\u00fcgen Strg + L Bildschirm leeren Strg + Alt/Shift + T Terminalfenster \u00f6ffnen (Alt oder Shift sollte funktionieren) Tab automatische Vervollst\u00e4ndigung Pfeiltasten oben/unten zuletzt benutze Befehle man <befehl> \u00f6ffnet das Manual f\u00fcr den entsprechenden Befehl","title":"GUI Desktop Tastenkombinationen"},{"location":"woche/woche1.html#beispiel-fur-eine-package-installation","text":"Das Programm sl (steam locomotive - Dampflokomotive) wird folgenderma\u00dfen installiert. sudo apt install sl Ruft man dann sl auf /usr/games/sl sieht man eine Lokomotive \u00fcber den Bildschirm fahren: Hinweis: in der Regel ist das Verzeichnis /usr/games nicht im Suchpfad der Shell. Will man nur den Programmnamen ohne Pfad beim Aufruf angeben, gibt es zwei M\u00f6glichkeiten: Den Suchpfad der Shell erweitern: PATH=$PATH:/usr/games Ein alias f\u00fcr das Programm anlegen alias sl='/usr/games/sl'","title":"Beispiel f\u00fcr eine Package Installation"},{"location":"woche/woche1.html#debian-paktetverwaltung","text":"Wei\u00df man nicht genau, in welchem Debian Paket ein Programm enthalten ist, kann man das Pakte mit Hilfe der Debian-Paketsuche","title":"Debian Paktetverwaltung"},{"location":"woche/woche1.html#warum-gibt-es-die-eintrage-und-in-einem-verzeichnis","text":"In jedem Verzeichnis gibt es die beiden Eintr\u00e4ge . und .. : . verweist auf das aktuelle Verzeichnis cd . : es \u00e4ndert sich nicht, ich befinde mich immer noch im gleichen Verzeichnis .. verweist auf das \u00fcbergeordnete Verzeichnis (parent directory) cd .. : ich wechsele in das \u00fcbergeordnete Verzeichnis","title":"Warum gibt es die Eintr\u00e4ge . und .. in einem Verzeichnis?"},{"location":"woche/woche1.html#verzeichniseintrag","text":"Angenommen ich befinde mich derzeit im Verzeichnis /home/openhpi/linux_cli und gebe dort die folgenden Kommandos ein ($ ist das Prompt (Eingabeaufforderung) der Shell. Die Zeichen nach dem $ sind die Eingaben, die Zeilen ohne $ am Anfang sind die Ausgaben) $ pwd /home/openhpi/linux_cli $ find week1-dir -type d -print week1-dir week1-dir/dir3 week1-dir/dir2 week1-dir/dir2/.hidden week1-dir/dir1 $ cd week1-dir/dir1 $ pwd /home/openhpi/linux_cli/week1-dir/dir1 Jetzt m\u00f6chte ich in das Verzeichnis /home/openhpi/linux_cli/week1-dir . Die folgenden cd Kommandos kann man dazu nicht verwenden. $ cd - : wechsele zur\u00fcck in das letzte Verzeichnis (_/home/openhpi/linux_cli_) $ cd : wechsele in das Homeverzeichnis der Kennung (_/home/openhpi_) D.h. ich muss das folgende eingeben: $ cd /home/openhpi/linux_cli/week1-dir Mit Hilfe des Verzeichniseintrags .. kann ich aber kurz schreiben $ cd .. Vorteil: erstens ist diese Schreibweise k\u00fcrzer - aber viel wichtiger: ich brauche dabei den Namen des Verzeichnisses, in das ich wechseln will, nicht kennen.","title":"Verzeichniseintrag .."},{"location":"woche/woche1.html#kuriose-ausnahme","text":"Das Rootverzeichnis / eines Dateisystems enth\u00e4lt auch die Eintr\u00e4ge . und .. In diesem Fall verweisen sowohl . als auch .. auf /","title":"Kuriose Ausnahme"},{"location":"woche/woche1.html#verzeichniseintrag_1","text":"Der nutzen von .. sollte einigerma\u00dfen klar sein. Frage: warum braucht man den Eintrag . ? Beispiel: in meinem aktuellen Verzeichnis gibt es die ausf\u00fchrbare Datei hallo, die beider Ausf\u00fchrung Hallo ausgibt. Wenn ich den Namen einfach als Kommando in die Shell eingebe, passiert das Folgende: $ hallo -bash: hallo: command not found Warum ist das so? Die Shell interpretiert hallo als auszuf\u00fchrendes Kommando. Das es kein in die Shell eingebautes Kommando ist, muss sie wissen, wo im Dateisystem die Datei zu finden ist. Dazu benutzt die Shell die Variable PATH $ echo $PATH /usr/local/bin:/usr/bin:/bin Hier kann man mehrere durch : getrennte Verzeichnisse angeben. Im obigen Beispiel w\u00fcrde die Shell in der folgenden Reihenfolge nach der Datei hallo suchen: /usr/local/bin/hallo /usr/bin/hallo /bin/hallo Dabei gilt: der erste Treffer wird ausgef\u00fchrt. Man kann nat\u00fcrlich das akutelle Verzeichnis, in dem man sich befindet, zur Variabeln PATH hinzuf\u00fcgen: $ PATH = \" $PATH : $( pwd ) \" Aber das ist nat\u00fcrlich nicht immer sinnvoll. Will man wissen, wo im Pfad ($PATH) das Kommando gefunden wurde, kann man das Kommando type nutzen: $ type ls ls is hashed ( /bin/ls ) N\u00e4chster Versuch: $ bash hallo Hallo Sieht gut aus, es kann aber auch das Folgende passieren: bash hallo hallo: hallo: cannot execute binary file Warum? Beim Aufruf $ bash hallo erwartet die Bash, das die Datei hallo ein Bash Skript enth\u00e4lt. Von welchem Typ meine ausf\u00fchrbare Datei ist (Shell Skript oder Programm), sieht man mit dem folgenden Kommando: $ file hallo hallo: Bourne-Again shell script, ASCII text executable $ file hallo hallo: ELF 64 -bit LSB pie executable, x86-64, version 1 ( SYSV ) , dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID [ sha1 ]= 1dc10461ed0684ca195d2712ba9a0205d2989543, for GNU/Linux 3 .2.0, not stripped Ohne den Typ zu kennen, m\u00fcsste man das Skript/Programm folgenderma\u00dfen aufrufen: $ /home/openhpi/linux_cli/week1-dir/dir1/hallo Hallo Mit Hilfe des builtin Kommandos pwd in der Shell geht das auch so: $ $( pwd ) /hallo Hallo Da . auf das aktuelle Verzeichnis verweist, kann man aber auch einfach das Folgende aufrufen: $ ./hallo Hallo Sollen immer alle ausf\u00fchrbaren Dateien im aktuellen Verzeichnis von der Shell gefunden werden, kann man die Variable PATH folgenderma\u00dfen erweitern: $ PATH = \" $PATH :.\" Bleibt noch die Frage, warum $ ./hallo als Bash Skript ausgef\u00fchrt wird. L\u00f6sung: die Datei Datei sieht folgenderma\u00dfen aus: $ cat hallo #!/bin/bash # echo \"Hallo\" Wichtig ist hierbei die erste Zeile: #!/bin/bash Diese Zeile wird als Shebang bezeichnet. Die Shell nimmt in diesem Fall an, dass die Zeichenkette nach \"#!\" ein Kommando ist. Die Shell ruft dieses Kommando auf und \u00fcbergibt den Rest der Datei an das Kommando.","title":"Verzeichniseintrag ."},{"location":"woche/woche1.html#weitere-informationen","text":"Wikipedia: Dateisystem Wikipedia: Inode","title":"Weitere Informationen"},{"location":"woche/woche1.html#daten-fur-die-praktische-ubung-19","text":"Die Daten f\u00fcr die Praktische \u00dcbung 1.9 habe ich hier abgelegt: week1-dir/ Ausgepacktes Archiv week1-dir.tar.gz TAR Datei der Daten week1-dir.zip Die original ZIP Datei Auspacken der TAR Datei: tar xvf week1-dir.tar.gz finden.","title":"Daten f\u00fcr die Praktische \u00dcbung 1.9"},{"location":"woche/woche1.html#zusammenfassung-der-woche-1","text":"Linux verwendet, \u00e4hnlich wie Windows, ein Dateisystem mit Verzeichnissen und Dateien. Loggt man sich and der Console ein, oder \u00f6ffnet in einer GUI ein Terminalfenster befindet man sich im sogenannten Homeverzeichnis der Kennung. Das Verzeichnis, in dem man sich gerade befindet, kann man sich mit dem Kommando pwd ansehen: $ pwd /home/openhpi Mit dem Kommando cd kann man das Verzeichnis wechseln. $ cd linux_cli $ pwd /home/openhpi/linux_cli Es gibt 3 spezielle M\u00f6glichkeiten, das Kommando cd zu nutzen: cd : wechsel in das Homeverzeichnis cd ~ : wechsel in das Homeverzeichnis cd - : wechsel in das letzte Verzeichnis Beispiel: $ pwd /home/openhpi $ cd linux_cli $ pwd /home/openhpi/linux_cli $ cd $ pwd /home/openhpi $ cd linux_cli $ pwd /home/openhpi/linux_cli $ cd ~ $ pwd /home/openhpi $ cd linux_cli $ pwd /home/openhpi/linux_cli $ cd week1-dir $ pwd /home/openhpi/linux_cli/week1-dir $ cd - /home/openhpi/linux_cli $ pwd /home/openhpi/linux_cli Die in einem Verzeichns vorhandenen Verzeichnisse/Dateien kann man sich mit dem Kommando ls ansehen. In Linux gibt es eine Reihe von Rechte im Dateisystem . Diese Rechte kann man mit dem Kommando chmod ver\u00e4ndern. Zur Installation von Programmen ben\u00f6tigt man eine Administratorberechtigung. In einer Desktop Linux Umgebung ist in der Regle mindestens ein Benutzer so konfiguriert, dass er das Programm sudo aufrufen kann. Dieser Benutzer kann das Software auf dem Rechner installieren. Beispiel: sudo apt install fortune","title":"Zusammenfassung der Woche 1"},{"location":"woche/woche2.html","text":"Woche 2 Themen der Woche 2 Pipes und Filters Konsolenanwendungen Komfortabel in der Kommandozeile In den Videos wird die folgende Beispieldatei genutzt: rezept.txt Standard Streams stdin Stream f\u00fcr die Eingabedaten (z.B. Eingagen \u00fcber die Tastatur) stdout Stream f\u00fcr die Ausgabedaten stderr Stream f\u00fcr die Fehlermeldungen Filter Filter sind Programme, die Daten von stdin lesen und nach stdout ausgeben. Pipes (Pipelines) Pipes verbinden 2 oder mehr Filter. Dabei wird die stdout Ausgabe des Vorg\u00e4ngers an stdin Eingabe des Nachfolgers weitergeleitet. Hintergrundprozesse Zum Thema jobs (Vodergrund-/Hintergrundprozesse) gibt es einen kurzen \u00dcbersichtsartikel: Jobs im Griff mit jobs, bg, fg und & . Erg\u00e4nzend kann man in der Shell noch folgendes nutzen: nach dem Starten eines Kommandos/Prozesses im Hintergrund kann man sich seine Prozess ID (pid) \u00fcber die Variable $! holen. sleep 100 & bgpid = $! Die PID des laufenden Shell Prozesses bekommt man \u00fcber die Variable $$. Wenn man auf das Ende eine Hintergrundprozesses warten will, geht das \u00fcber das Kommando wait wait $bgpid Wie erkenne ich, das ein Prozess ein Hintergrundprozesse meiner Shell ist? Die PPID (Parent PID) des Hintergrundprozesses verweist auf die PID meines Shell Prozesses. Jetzt alles zusammen: sleep 3 & bgpid = $! echo \"pid : $$ \" echo \"bgpid : $bgpid \" echo \"\" ps -opid,ppid,cmd echo \"----------\" # echo \"\" wait $bgpid ps -opid,ppid,cmd echo \"----------\" Die Ausgabe sieht dann im Wesentlichen so aus (die Prozesse oberhalb von -bash habe ich aus der Liste gel\u00f6scht): pid : 1724923 bgpid : 1724924 PID PPID CMD 1724826 1724825 -bash 1724923 1724826 /bin/bash ./xx 1724924 1724923 sleep 3 1724925 1724923 ps -opid,ppid,cmd ---------- PID PPID CMD 1724826 1724825 -bash 1724923 1724826 /bin/bash ./xx 1724926 1724923 ps -opid,ppid,cmd ---------- Der sleep Hintergrundprozess hat die PID 1724924 und die PPID 1724923. Das ist die PID von meinem laufenden Skript xx. Kommandos verketten Man kann in einer Anweisung mehrere Kommandos angeben (verketten). Da jedes Kommando bei seiner Beendigung einen Exit Code zur\u00fcckliefert, kann man mit Hilfe dieses Wertes die Abarbeitung der Verkettung steuern. Der Exit Code eines Kommandos ist eine Zahl >=0 und kann direkt nach dem Ende des Kommandos in der Shell mit der Variablen $? abgefragt werden. Dabei bedeutet 0 ein erfolgreiches Ende des Kommandos und ungleich 0, das ein Fehler im Ablauf des Kommandos aufgetreten ist. $ ls week1-dir $ echo $? 0 $ ls unbekannteDatei ls: cannot access 'unbekannteDatei' : No such file or directory $ echo $? 2 Kommandos bis zum ersten Fehler ausf\u00fchren kommando_1 && kommando_2 && ... && kommando_n Die Kommandos werden nacheinander ausgef\u00fchrt, bis ein Fehler in einem Kommando auftritt. Beispiel: ls datei1 && echo \"wird nur angezeigt, wenn es datei1 gibt\" Kommandos bis zum ersten Erfolg ausf\u00fchren kommando_1 || kommando_2 || ... || kommando_n Die Kommandos werden nacheinander ausgef\u00fchrt, bis das erste Kommando erfolgreich ausgef\u00fchrt wurde. Beispiel: ls datei1 || echo \"wird nur angezeigt, wenn es datei1 nicht gibt\" Kommandos verketten Mit dem Zeichen ; k\u00f6nnen Kommandos verkettet werden kommando_1 ; kommando_2 ; ... ; kommando_n Alle Kommandos werden nacheinander ausgef\u00fchrt - egal ob ein Fehler aufgetreten ist oder nicht. Shell Eigenschaften Environmentvariablen Shellvariablen sind nur in der aktuelle Shell bekannt. Environmentvariablen dagegen werden an alle Subprozesse der Shell vererbt. Ein Subprozess ist ein Prozess, der von der aktuellen Shell gestartet wurde. Eine Variable wird zu einer Environmentvariablen, indem man sie mit export deklariert: export ENV_VARIABLE = \"Hallo\" Oder auch l\u00e4nger: ENV_VARIABLE = \"Hallo\" export ENV_VARIABLE All derzeit deklarierten Environmentvariablen kann man sich mit dem folgenden Kommando ausgeben lassen: env Die folgenden Environmentvariablen sind in der Shell immer gesetzt: HOME Enth\u00e4lt das Homeverzeichni des Benutzers PATH Enth\u00e4lt (durch : getrennt) alle Verzeichnisse, in denen die Shell nach einem Kommando sucht. alias / unalias Mit alias kann man sich ein eigenes Kommando builden. alias ll = 'ls -l' alias bilder = 'cd $HOME/Bilder;pwd' Gibt man ll ein, wird das Kommando ls -l ausgef\u00fchrt. Gibt man bilder ein, wird die Kommandoverkettung cd $HOME/Bilder;pwd ausgef\u00fchrt. Mit unalias kann man ein vorher erzeugtes Alias l\u00e4schen. unalias ll Gibt man nur alias ein, werden alle deklarierten Aliases angezeigt. alias History Die Shell f\u00fchrt eine History der aufgerufenen Kommandos. history : anzeigen der History Strg + R : suchen in History !! : letztes Komando wiederholen Kommando !! : Kommando mit dem letzten Kommando als Argument ausf\u00fchren TLDR (Too Long Didn't Read) Die gesamte TLDR Umgebung ist im GitHub unter der Kennung tldr pages abgelegt. Der Standard Client ist ein Python Skript ( tldr-python-client ). Auf dieser Seite gibt es auch eine Beschreibung zur Konfiguration und dem Aufruf des Clients. Die von tldr ausgegeben Texte sind im Repository tldr-pages/tldr abgelegt.","title":"Woche2"},{"location":"woche/woche2.html#woche-2","text":"Themen der Woche 2 Pipes und Filters Konsolenanwendungen Komfortabel in der Kommandozeile In den Videos wird die folgende Beispieldatei genutzt: rezept.txt","title":"Woche 2"},{"location":"woche/woche2.html#standard-streams","text":"stdin Stream f\u00fcr die Eingabedaten (z.B. Eingagen \u00fcber die Tastatur) stdout Stream f\u00fcr die Ausgabedaten stderr Stream f\u00fcr die Fehlermeldungen","title":"Standard Streams"},{"location":"woche/woche2.html#filter","text":"Filter sind Programme, die Daten von stdin lesen und nach stdout ausgeben.","title":"Filter"},{"location":"woche/woche2.html#pipes-pipelines","text":"Pipes verbinden 2 oder mehr Filter. Dabei wird die stdout Ausgabe des Vorg\u00e4ngers an stdin Eingabe des Nachfolgers weitergeleitet.","title":"Pipes (Pipelines)"},{"location":"woche/woche2.html#hintergrundprozesse","text":"Zum Thema jobs (Vodergrund-/Hintergrundprozesse) gibt es einen kurzen \u00dcbersichtsartikel: Jobs im Griff mit jobs, bg, fg und & . Erg\u00e4nzend kann man in der Shell noch folgendes nutzen: nach dem Starten eines Kommandos/Prozesses im Hintergrund kann man sich seine Prozess ID (pid) \u00fcber die Variable $! holen. sleep 100 & bgpid = $! Die PID des laufenden Shell Prozesses bekommt man \u00fcber die Variable $$. Wenn man auf das Ende eine Hintergrundprozesses warten will, geht das \u00fcber das Kommando wait wait $bgpid Wie erkenne ich, das ein Prozess ein Hintergrundprozesse meiner Shell ist? Die PPID (Parent PID) des Hintergrundprozesses verweist auf die PID meines Shell Prozesses. Jetzt alles zusammen: sleep 3 & bgpid = $! echo \"pid : $$ \" echo \"bgpid : $bgpid \" echo \"\" ps -opid,ppid,cmd echo \"----------\" # echo \"\" wait $bgpid ps -opid,ppid,cmd echo \"----------\" Die Ausgabe sieht dann im Wesentlichen so aus (die Prozesse oberhalb von -bash habe ich aus der Liste gel\u00f6scht): pid : 1724923 bgpid : 1724924 PID PPID CMD 1724826 1724825 -bash 1724923 1724826 /bin/bash ./xx 1724924 1724923 sleep 3 1724925 1724923 ps -opid,ppid,cmd ---------- PID PPID CMD 1724826 1724825 -bash 1724923 1724826 /bin/bash ./xx 1724926 1724923 ps -opid,ppid,cmd ---------- Der sleep Hintergrundprozess hat die PID 1724924 und die PPID 1724923. Das ist die PID von meinem laufenden Skript xx.","title":"Hintergrundprozesse"},{"location":"woche/woche2.html#kommandos-verketten","text":"Man kann in einer Anweisung mehrere Kommandos angeben (verketten). Da jedes Kommando bei seiner Beendigung einen Exit Code zur\u00fcckliefert, kann man mit Hilfe dieses Wertes die Abarbeitung der Verkettung steuern. Der Exit Code eines Kommandos ist eine Zahl >=0 und kann direkt nach dem Ende des Kommandos in der Shell mit der Variablen $? abgefragt werden. Dabei bedeutet 0 ein erfolgreiches Ende des Kommandos und ungleich 0, das ein Fehler im Ablauf des Kommandos aufgetreten ist. $ ls week1-dir $ echo $? 0 $ ls unbekannteDatei ls: cannot access 'unbekannteDatei' : No such file or directory $ echo $? 2","title":"Kommandos verketten"},{"location":"woche/woche2.html#kommandos-bis-zum-ersten-fehler-ausfuhren","text":"kommando_1 && kommando_2 && ... && kommando_n Die Kommandos werden nacheinander ausgef\u00fchrt, bis ein Fehler in einem Kommando auftritt. Beispiel: ls datei1 && echo \"wird nur angezeigt, wenn es datei1 gibt\"","title":"Kommandos bis zum ersten Fehler ausf\u00fchren"},{"location":"woche/woche2.html#kommandos-bis-zum-ersten-erfolg-ausfuhren","text":"kommando_1 || kommando_2 || ... || kommando_n Die Kommandos werden nacheinander ausgef\u00fchrt, bis das erste Kommando erfolgreich ausgef\u00fchrt wurde. Beispiel: ls datei1 || echo \"wird nur angezeigt, wenn es datei1 nicht gibt\"","title":"Kommandos bis zum ersten Erfolg ausf\u00fchren"},{"location":"woche/woche2.html#kommandos-verketten_1","text":"Mit dem Zeichen ; k\u00f6nnen Kommandos verkettet werden kommando_1 ; kommando_2 ; ... ; kommando_n Alle Kommandos werden nacheinander ausgef\u00fchrt - egal ob ein Fehler aufgetreten ist oder nicht.","title":"Kommandos verketten"},{"location":"woche/woche2.html#shell-eigenschaften","text":"","title":"Shell Eigenschaften"},{"location":"woche/woche2.html#environmentvariablen","text":"Shellvariablen sind nur in der aktuelle Shell bekannt. Environmentvariablen dagegen werden an alle Subprozesse der Shell vererbt. Ein Subprozess ist ein Prozess, der von der aktuellen Shell gestartet wurde. Eine Variable wird zu einer Environmentvariablen, indem man sie mit export deklariert: export ENV_VARIABLE = \"Hallo\" Oder auch l\u00e4nger: ENV_VARIABLE = \"Hallo\" export ENV_VARIABLE All derzeit deklarierten Environmentvariablen kann man sich mit dem folgenden Kommando ausgeben lassen: env Die folgenden Environmentvariablen sind in der Shell immer gesetzt: HOME Enth\u00e4lt das Homeverzeichni des Benutzers PATH Enth\u00e4lt (durch : getrennt) alle Verzeichnisse, in denen die Shell nach einem Kommando sucht.","title":"Environmentvariablen"},{"location":"woche/woche2.html#alias-unalias","text":"Mit alias kann man sich ein eigenes Kommando builden. alias ll = 'ls -l' alias bilder = 'cd $HOME/Bilder;pwd' Gibt man ll ein, wird das Kommando ls -l ausgef\u00fchrt. Gibt man bilder ein, wird die Kommandoverkettung cd $HOME/Bilder;pwd ausgef\u00fchrt. Mit unalias kann man ein vorher erzeugtes Alias l\u00e4schen. unalias ll Gibt man nur alias ein, werden alle deklarierten Aliases angezeigt. alias","title":"alias / unalias"},{"location":"woche/woche2.html#history","text":"Die Shell f\u00fchrt eine History der aufgerufenen Kommandos. history : anzeigen der History Strg + R : suchen in History !! : letztes Komando wiederholen Kommando !! : Kommando mit dem letzten Kommando als Argument ausf\u00fchren","title":"History"},{"location":"woche/woche2.html#tldr-too-long-didnt-read","text":"Die gesamte TLDR Umgebung ist im GitHub unter der Kennung tldr pages abgelegt. Der Standard Client ist ein Python Skript ( tldr-python-client ). Auf dieser Seite gibt es auch eine Beschreibung zur Konfiguration und dem Aufruf des Clients. Die von tldr ausgegeben Texte sind im Repository tldr-pages/tldr abgelegt.","title":"TLDR (Too Long Didn't Read)"}]}