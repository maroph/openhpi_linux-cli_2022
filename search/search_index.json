{"config":{"lang":["de"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"openHPI Kurs Linux in der Kommandozeile","text":"<p>Vom 9. Februar 2022 bis 2. M\u00e4rz 2022 l\u00e4uft der openHPI Kurs Linux in der Kommandozeile.</p> <p>Diese Site ist meine Begleitseite zu diesem Kurs.</p>"},{"location":"info/about.html","title":"\u00dcber diese Site","text":"<p>Der gesamte Inhalt dieser Site (HTML und Skripte) ist abgelegt in meinem GitHub Repository.</p>"},{"location":"info/about.html#benutzte-linux-versionen","title":"Benutzte Linux Versionen","text":"<p>F\u00fcr meine Beispiele habe ich die folgenden Linux Versionen benutzt:</p> <p>Debian 11.2 on WSL2 (Windows Subsystem for Linux) <pre><code>echo $BASH_VERSION\n5.1.4(1)-release\n</code></pre></p> <p>Raspberry Pi OS 10.11 <pre><code>echo $BASH_VERSION\n5.0.3(1)-release\n</code></pre></p>"},{"location":"info/about.html#struktur-der-site","title":"Struktur der Site","text":"<p>Die Daten auf dieser Site sind folgenderma\u00dfen strukturiert:</p> <ul> <li>docs-src   Markdown Sourcen dieser Site</li> <li>LICENSE   Lizenz des Repositories (CC-BY 4.0)</li> <li>README.md   Readme Datei des Repositories</li> <li>mkdocs.yml MkDocs Konfigurationsdatei</li> </ul>"},{"location":"info/about.html#mkdocs-virtual-environment","title":"MkDocs Virtual Environment","text":"<p>F\u00fcr MkDocs verwende ich das folgende Virtual Environment:</p> <pre><code>python3 -m venv venv\nsource venv/bin/activate\npython -m pip install --upgrade pip\npython -m pip install --upgrade setuptools\npython -m pip install --upgrade wheel\npython -m pip install --upgrade mkdocs\npython -m pip install --upgrade mkdocs-material\npython -m pip install --upgrade mkdocs-git-revision-date-plugin\n</code></pre> <p>Sollte das Modul venv nicht installiert sein, muss man das Package python3-venv installieren.</p> <p>Auf Debian/Ubuntu/Raspbian geht das mit dem folgenden Kommando</p> <pre><code>sudo apt install python3-venv\n</code></pre>"},{"location":"info/about.html#lokale-erzeugung-der-site","title":"Lokale Erzeugung der Site","text":"<pre><code>./build\n</code></pre>"},{"location":"info/about.html#veroffentlichung-der-site","title":"Ver\u00f6ffentlichung der Site","text":"<p>F\u00fcr mein GitHub Repository habe ich die GitHub Page </p> <p>https://maroph.github.io/openhpi_linux-cli_2022/</p> <p>konfiguriert. F\u00fcr diese GitHub Page werden die Daten aus dem Verzeichnis /  im Branch gh-pages verwendet.</p> <p>Um diese Page zu aktualisieren, muss man die \u00c4nderungen im lokalen Git Repository committen und in das GitHub Repository pushen:</p> <pre><code>git commit -m \"my commit message\"\ngit push\n./build deploy\n</code></pre> <p>Nach einer relativ kurzen Zeit sind die \u00c4nderungen auf der GitHub Page zu sehen.</p>"},{"location":"info/license.html","title":"Lizenz","text":"<p> Die Daten auf dieser Site sind lizenziert unter einer Creative Commons Namensnennung 4.0 International Lizenz.</p> <p>tl;dr:CC-BY 4.0.</p>"},{"location":"info/links.html","title":"Links","text":""},{"location":"info/links.html#bash","title":"Bash","text":"<ul> <li>Advanced Bash-Scripting Guide</li> <li>Bash Builtins</li> <li>Bash Guide for Beginners</li> <li>Bash Hackers Wiki</li> <li>Bash Prompt HOWTO</li> <li>Bash Reference Manual</li> <li>Bash FAQ</li> <li>Bash scripting cheatsheet</li> <li>Pure Bash Bible</li> <li>Rheinwerk Linux</li> <li>SelfLinux</li> <li>Wie man Funktionen in Bash verwendet</li> </ul>"},{"location":"info/links.html#linux","title":"Linux:","text":"<ul> <li>Debian 10 Administrationshandbuch</li> <li>Debian mount commando</li> <li>Debian Paketsuche</li> <li>Flatpak</li> <li>Flathub</li> <li>How to Change Colors on LS in Bash</li> <li>How to Mount a USB Drive in Debian</li> <li>How to mount partition with ntfs file system and read write access</li> <li>Introduction to Linux</li> <li>Jobs im Griff mit jobs, bg, fg und &amp;</li> <li>JSLinux   Linux im Browser (Chrome, Edge, Firefox, ...)   Alpine Linux 3.12 mit einem Kernel 4.12</li> <li>Linux Manpages: die.net</li> <li>Linux Manpages:man.cx</li> <li>LPIC: Linux Essentials   Linux Einf\u00fchrungskurs</li> <li>LPIC: LPIC-1   Eine Vertiefung des LPIC-1 Kurses</li> <li>Rechte im Dateisystem</li> <li>RegexLearn</li> <li> Regular-Expressions.info</li> <li> Regular-Expressions.info: Tutorial</li> <li>Regul\u00e4re Ausdr\u00fccke in der Praxis</li> <li>Rheinwerk: Linux - Das umfassende Handbuch</li> <li>Rheinwerk: Wie werde ich UNIX-Guru?</li> <li>snap</li> <li>snapcraft.io</li> <li>Technische Praxis der Computersysteme   Vorlesung im Wintersemester 2015 an der Universit\u00e4t Wien.   Diese Vorlesung bietet eine gute Einf\u00fchrung in Linux.</li> <li>The Linux Command Line</li> <li>The TTY demystified</li> <li>Unicode Collation Algorithm</li> <li>Using 'apt search' and 'apt show'</li> <li>Wikipedia: Dateisystem</li> <li>Wikipedia: Inode</li> <li>Wikipedia: Unix-Dateirechte</li> <li>Why are hard links not allowed for directories?</li> <li>Windows-Subsystem f\u00fcr Linux: Dokumentation</li> <li>WSL: Konfiguration der erweiterten Einstellungen in WSL</li> <li>WSL 2 and VPN - get the best route</li> </ul>"},{"location":"info/links.html#tools","title":"Tools","text":"<ul> <li>awk User's Guide</li> <li>Crontab: A Beginners Guide To Cron Jobs</li> <li>Cron Ubuntu Wiki</li> <li>crontab guru</li> <li>Crontab Syntax und Tutorial</li> <li>GNU Grep 3.7</li> <li> grep Cheat Sheet</li> <li>ncat Manpage</li> <li>ncat User's Guide</li> <li>RegEx 101   Auf dieser Seite kann man interaktiv verschiedene Muster ausprobieren.</li> <li>script Manpage   Ein Tool f\u00fcr die Aufzeichnung aller Ein-/Ausgaben in einer Konsole.</li> <li>screen Manpage</li> <li>screen User's Manual</li> <li>sed: N\u00fctzliche, einzeilige Scripts</li> <li>sed User's Guide</li> </ul>"},{"location":"info/sources.html","title":"Quellenreferenz","text":"<p>Diese Site wurde mit MkDocs erstellt. Zus\u00e4tzlich habe ich das Theme  Material for MkDocs und das Plugin mkdocs-git-revision-date-plugin verwendet.</p> <p>Das von mir verwendete Linux Logo ist einer verkleinerte Version der Datei \"Linux Logo\" von  laboratoriolinux  und ist lizenziert unter  CC BY-NC-SA 2.0</p>"},{"location":"samples/index.html","title":"Beispiele","text":"<p>In diesem Bereich gibt es eine Reihe von Beispielen.</p>"},{"location":"samples/bash_arrays.html","title":"Bash: Arrays","text":""},{"location":"samples/bash_arrays.html#anlegen-eines-arrays","title":"Anlegen eines Arrays","text":""},{"location":"samples/bash_arrays.html#anlegen-eines-leeren-arrays","title":"Anlegen eines leeren Arrays","text":"<pre><code>declare -a array\n</code></pre>"},{"location":"samples/bash_arrays.html#anlegen-eines-vorbelegten-arrays","title":"Anlegen eines vorbelegten Arrays","text":"<pre><code>declare -a arrayPre=(wert1 wert2 wert3 wert4)\n</code></pre>"},{"location":"samples/bash_arrays.html#werte-an-ein-array-anhangen","title":"Werte an ein Array anh\u00e4ngen","text":"<pre><code>array+=(\"wert1\")\narray+=(\"wert2\")\narray+=(\"wert3\")\narray+=(\"wert4\")\n</code></pre>"},{"location":"samples/bash_arrays.html#zugriff-auf-ein-element-mit-index","title":"Zugriff auf ein Element mit Index","text":"<p>Das erste Element in einem Bash Array hat den Index 0.</p> <pre><code>echo \"${array[0]}\"\necho \"${array[1]}\"\n</code></pre>"},{"location":"samples/bash_arrays.html#einer-wert-mit-index-setzen","title":"Einer Wert mit Index setzen","text":"<pre><code>array[1]=\"wert2_neu\"\necho \"${array[1]}\"\n</code></pre> <p><pre><code>array[5]=\"wert5\"\necho \"${array[5]}\"\n</code></pre> Was ist der Wert vom Element mit dem nicht belegtem Index 4 ?</p> <p><pre><code>echo \"${array[4]}\"\n</code></pre> Da dem Array mit dem Index 4 noch kein Wert zugewiesen wurde, wird der Ausdruck ${array[4]} zu einem Leerstring expandiert</p>"},{"location":"samples/bash_arrays.html#lange-eines-arrays","title":"L\u00e4nge eines Arrays","text":"<pre><code>echo \"L\u00e4nge des Arrays array    : ${#array[@]}\"\necho \"L\u00e4nge des Arrays arrayPre : ${#arrayPre[@]}\"\n</code></pre>"},{"location":"samples/bash_arrays.html#array-kopieren","title":"Array kopieren","text":"<pre><code>array2=(\"${array[@]}\")\n</code></pre>"},{"location":"samples/bash_arrays.html#array-konkatenieren","title":"Array konkatenieren","text":"<pre><code>array3=(\"${array[@]}\" \"${array2[@]}\")\n</code></pre>"},{"location":"samples/bash_arrays.html#teilbereich-vonbis-eines-arrays-ausgeben","title":"Teilbereich (von/bis) eines Arrays ausgeben","text":"<p><pre><code>echo \"${array[@]:1:4}\"\n</code></pre> Es werden die Werte mit dem Index 1-3 ausgegeben. Der erste Wert (1) gibt an, ab welchem Index die Ausgabe bebinnt und der zweite Wert (4) gibt den ersten Index an, dessen Wert nicht mehr ausgegeben werden soll.</p>"},{"location":"samples/bash_arrays.html#ausgabe-des-gesamten-arrays","title":"Ausgabe des gesamten Arrays","text":"<pre><code>echo \"${array[@]}\"\n</code></pre>"},{"location":"samples/bash_arrays.html#werte-bei-der-ausgabe-ersetzen","title":"Werte bei der Ausgabe ersetzen","text":"<p><pre><code>echo \"${array[@]/wert/value}\"\n</code></pre> Dieser Ausdruck gibt alle Werte des Array aus. Dabei wird der String \"wert\" durch den String \"value\" ersetzt.</p>"},{"location":"samples/bash_arrays.html#iteration-uber-ein-array","title":"Iteration \u00fcber ein Array","text":"<pre><code>for wert in \"${array[@]}\"\ndo\n    echo \"Wert : ${wert}\"\ndone\n</code></pre>"},{"location":"samples/bash_arrays.html#prufen-ob-ein-wert-im-array-enthalten-ist","title":"Pr\u00fcfen, ob ein Wert im Array enthalten ist","text":"<pre><code>if [[ \" ${array[@]} \" =~ \" wert1 \" ]]\nthen\n    echo \"der Wert wert1 ist im Array array enthalten\"\nfi\n</code></pre>"},{"location":"samples/bash_arrays.html#prufen-ob-ein-wert-nicht-im-array-enthalten-ist","title":"Pr\u00fcfen, ob ein Wert nicht im Array enthalten ist","text":"<pre><code>if [[ ! \" ${array[@]} \" =~ \" wertNONE \" ]]\nthen\n    echo \"der Wert wertNone ist im Array array NICHT enthalten\"\nfi\n</code></pre>"},{"location":"samples/bash_arrays.html#loschen-eines-elementes-aus-einem-array","title":"L\u00f6schen eines Elementes aus einem Array","text":"<pre><code>unset array[5]\n</code></pre>"},{"location":"samples/bash_arrays.html#loschen-eines-arrays","title":"L\u00f6schen eines Arrays","text":"<p>unset array</p>"},{"location":"samples/bash_arrays.html#zeilenweises-einlesen-einer-datei-in-ein-array","title":"Zeilenweises Einlesen einer Datei in ein Array","text":"<p>Diesen Code habe ich in der BashFAQ/005 im Kapitel \"2.1. Loading lines from a file or stream\" gefunden.</p> <pre><code>mapfile -t array &lt; ./tmp.txt\necho \"Anzahl gelesener Zeilen: \\${#array[@]}: ${#array[@]}\"\nfor line in \"${array[@]}\"\ndo\n    echo \"&gt;&gt;&gt;&gt;&gt; ${line}\"\ndone\n</code></pre>  <p>Ein Skript, dass alle hier beschriebene Operationen ausf\u00fchrt, findet man hier: bash_arrays.bash</p>"},{"location":"samples/bash_assoziative_arrays.html","title":"Bash: Assoziative Arrays","text":""},{"location":"samples/bash_assoziative_arrays.html#anlegen-eines-arrays","title":"Anlegen eines Arrays","text":""},{"location":"samples/bash_assoziative_arrays.html#anlegen-eines-leeren-arrays","title":"Anlegen eines leeren Arrays","text":"<pre><code>declare -A aArray\n</code></pre>"},{"location":"samples/bash_assoziative_arrays.html#anlegen-eines-vorbelegten-arrays","title":"Anlegen eines vorbelegten Arrays","text":"<pre><code>declare -A aArrayPre=( [key1]=val1 [key2]=val2 [key3]=val3 )\n</code></pre>"},{"location":"samples/bash_assoziative_arrays.html#keyvalue-paare-zu-einem-array-hinzufugen","title":"Key/Value Paare zu einem Array hinzuf\u00fcgen","text":"<pre><code>aArray[\"key1\"]=\"value1\"\naArray[\"key2\"]=\"value2\"\n</code></pre>"},{"location":"samples/bash_assoziative_arrays.html#zugriff-auf-ein-element-mit-dem-schlussel-key","title":"Zugriff auf ein Element mit dem Schl\u00fcssel (key)","text":"<pre><code>echo \"${aArray[\"key1\"]}\"\necho \"${aArray[\"key2\"]}\"\n</code></pre>"},{"location":"samples/bash_assoziative_arrays.html#lange-eines-arrays","title":"L\u00e4nge eines Arrays","text":"<pre><code>echo \"L\u00e4nge des Arrays aArray : ${#aArray[@]}\"\n</code></pre>"},{"location":"samples/bash_assoziative_arrays.html#iteration-uber-den-schlussel-key","title":"Iteration \u00fcber den Schl\u00fcssel (key)","text":"<pre><code>for key in \"${!aArray[@]}\"\ndo\n    echo \"key : ${key}\"\n    echo \"key : ${key} , value: ${aArray[${key}]}\"\ndone\n</code></pre>"},{"location":"samples/bash_assoziative_arrays.html#iteration-uber-den-wert-value","title":"Iteration \u00fcber den Wert (value)","text":"<pre><code>for value in \"${aArray[@]}\"\ndo\n    echo \"value: ${value}\"\ndone\n</code></pre>"},{"location":"samples/bash_assoziative_arrays.html#prufen-ob-ein-schlussel-key-im-array-enthalten-ist","title":"Pr\u00fcfen, ob ein Schl\u00fcssel (key) im Array enthalten ist","text":"<pre><code>if [ ${aArray[key1]+_} ]\nthen\n    echo \"key1 gefunden\"\nfi\n</code></pre>"},{"location":"samples/bash_assoziative_arrays.html#prufen-ob-ein-schlussel-key-im-array-nicht-enthalten-ist","title":"Pr\u00fcfen, ob ein Schl\u00fcssel (key) im Array nicht enthalten ist","text":"<pre><code>if [ ! ${aArray[keyNONE]+_} ]\nthen\n    echo \"keyNONE nicht gefunden\"\nfi\n</code></pre>"},{"location":"samples/bash_assoziative_arrays.html#loschen-eines-schlussels-aus-einem-array","title":"L\u00f6schen eines Schl\u00fcssels aus einem Array","text":"<pre><code>unset aArray[key1]\n</code></pre>"},{"location":"samples/bash_assoziative_arrays.html#loschen-eines-arrays","title":"L\u00f6schen eines Arrays","text":""},{"location":"samples/bash_assoziative_arrays.html#unset-aarray","title":"<pre><code>unset aArray\n</code></pre>","text":"<p>Ein Skript, dass alle hier beschriebene Operationen ausf\u00fchrt, findet man hier: bash_aArrays.bash</p>"},{"location":"samples/bash_functions.html","title":"Bash: Funktionen","text":"<p>Werden Bl\u00f6cke von Statements in einem Skript an mehreren Stellen verwendet, ist praktisch, diese Bl\u00f6cke an einer Stelle im Skript zu hinterlegen und dann \u00fcberall dort, wo diese Bl\u00f6cke genutzt werden, auf diese Stelle zu verweisen.</p> <p>In der Bash sind das Funktionen, die man deklariert. Diese Funktionen k\u00f6nnen dann innerhalb eines Skripts aufgerufen werden.</p>"},{"location":"samples/bash_functions.html#funktionsdeklaration","title":"Funktionsdeklaration","text":"<p>Funktionen k\u00f6nnen auf zwei Arten deklariert werden.</p> <p>Variante 1  </p> <pre><code>function function_name() {\n    statement1\n    ...\n    statementN\n}\n</code></pre> <p>Variante 2  </p> <pre><code>function_name() {\n    statement1\n    ...\n    statementN\n}\n</code></pre>"},{"location":"samples/bash_functions.html#funktionsdeklaration-und-aufruf","title":"Funktionsdeklaration und Aufruf","text":"<p>Hier ein einfaches Besipiel in beiden Varianten</p> <pre><code>function hallo1() {\n    echo \"Hallo1!\"\n}\nhallo1\n</code></pre> <pre><code>hallo2() {\n    echo \"Hallo2!\"\n}\nhallo2\n</code></pre> <p>Der Aufruf einer Funktion sieht genauso aus wie der Aufruf eines Kommandos/Programms.</p>"},{"location":"samples/bash_functions.html#ubergabeparameter","title":"\u00dcbergabeparameter","text":"<p>Parameter werden genau wie bei Kommandos \u00fcbergeben. Im Scope der Funktion kann man f\u00fcr den Zugriff auf die Parameter die Shell Variable $1, ,,, $9, $#, $*, $@</p> <pre><code>function zeigeUebergabeParameter() {\n    echo \"Anzahl Parameter : $#\"\n    echo \"Parameter 1      : $1\"\n    echo \"Parameter 2      : $2\"\n    echo \"Alle Parameter:\"\n    echo \"$@\"\n}\nzeigeUebergabeParameter p1 p2 p3 p4\n</code></pre> <pre><code>Anzahl Parameter : 4\nParameter 1      : p1\nParameter 2      : p2\nAlle Parameter:\np1 p2 p3 p4\n</code></pre>"},{"location":"samples/bash_functions.html#globalelokale-variablen","title":"Globale/Lokale Variablen","text":"<p>Variablen, die au\u00dferhalb einer Funktion deklariert wurden (globale Variablen), k\u00f6nnen auch innerhalb einer Funktion genutzt und ge\u00e4ndert werden.</p> <p>Wird eine Variable in einer Funktion deklariert, ist sie nach dem Aufruf der Funktion auf au\u00dferhald der Funktion deklariert und ist damit auch eine globale Variable.</p> <p>Den G\u00fcltigkeitsbereich einer Variablen kann man auf eine Funktion beschr\u00e4nken, wenn man sie in der Funktion vor einer Variablendeklaration das Schl\u00fcsselwort local setzt.</p> <pre><code>var1=1\nvar2=2\n#\nuse_of_variables() {\n    local var1=10\n    var2=7\n    var3=42\n    local var4=2525\n    echo \"In der Funktion: var1: $var1, var2: $var2, var3: $var3, var4: $var4\"\n}\n#\necho \"Vor dem Aufruf der Funktion: var1: $var1, var2: $var2, var3: $var3, var4: $var4\"\nuse_of_variables\necho \"Nach dem Aufruf der Funktion: var1: $var1, var2: $var2, var3: $var3, var4: $var4\"\n</code></pre> <pre><code>Vor dem Aufruf der Funktion: var1: 1, var2: 2, var3: , var4:\nIn der Funktion: var1: 10, var2: 7, var3: 42, var4: 2525\nNach dem Aufruf der Funktion: var1: 1, var2: 7, var3: 42, var4:\n</code></pre>"},{"location":"samples/bash_functions.html#ruckgabewert","title":"R\u00fcckgabewert","text":"<p>Der R\u00fcckgabewert einer Bash Funktion ist der Exit Code des letzten ausgef\u00fchrten Statements.</p> <pre><code>FULL_SCRIPT_NAME=$0\n#\nfunction file_size() {\n    stat --format \"%n: %s Bytes\" $1\n}\nfile_size ${FULL_SCRIPT_NAME}\necho \"exit code : $?\"\necho \"\"\nfile_size diese_datei_gibt_es_nicht\necho \"exit code : $?\"\necho \"\"\n</code></pre> <p>Der obige Coder erzeugt die folgende Ausgabe:</p> <pre><code>./bash_functions.bash: 3314 Bytes\nexit code : 0\n\nstat: cannot statx 'diese_datei_gibt_es_nicht': No such file or directory\nexit code : 1\n</code></pre> <p>Mit dem Schl\u00fcsselwort return kann man eine Funktion jederzeit beenden und einen  Exit Code setzen.</p> <pre><code>FULL_SCRIPT_NAME=$0\n#\nfunction file_size_return() {\n    return 42\n    stat --format \"%n: %s Bytes\" $1\n}\nfile_size_return ${FULL_SCRIPT_NAME}\necho \"exit code : $?\"\n</code></pre> <p>Ausgabe:</p> <pre><code>exit code : 42\n</code></pre>  <p>Ein Skript, dass alle hier gezeigten Beispiele ausf\u00fchrt, findet man hier: bash_functions.bash</p>"},{"location":"samples/bash_variables.html","title":"Bash: Variablen","text":"<p>\u00dcber Bash Variablen gibt es sehr viel zu sagen. Eine kurze \u00dcbericht zu diesem Thema findet man hier: Bash scripting cheatsheet.</p> <p>Ich gebe hier nur einige Beispiele an, die ich des \u00f6fteren verwende.</p>"},{"location":"samples/bash_variables.html#spezielle-bash-variablen","title":"Spezielle Bash Variablen","text":"<pre><code>$BASH_VERSION : Version der verwendeten Bash\n$0            : Dateiname des aufgerufenen Shell Skripts\n$1, ..., $9   : die ersten 9 Argumente, die an das Shell Skript\n                \u00fcbergeben wurden\n$#            : Anzahl der an ein Skript \u00fcbergebenen Argumente\n$*            : Alle Argumente als ein String (Nutzung: \"$*\")\n$@            : Alle Argumente als einzelne Strings (Nutzung: \"$@\")\n$$            : PID (Process Id) des Bash Prozesses\n$?            : Exit Code (errno) des letzten Kommandos\n                Der Exit Code ist eine ganze Zahl im Bereich 0-255.\n                Nur der Wert 0 bedeutet, das kein Fehler aufgetreten ist.\n$!            : PID des zuletzt in der Bash gestarten Hintergrundprozesses\n$RANDOM       : erzeugt bei jedem Zugriff eine neue pseudorandom Zahl\n                im Bereich 0-32767\n</code></pre> <p>Die Standard errno Werte sind als C/C++ Makro Definitionen in C/C++ Include Dateien abgelegt und haben die folgende Form:</p> <pre><code>#define ENOENT           2      /* No such file or directory */\n</code></pre> <p>Auf einem Debian System findet man diese Makro Definitionen in den Dateien</p> <pre><code>/usr/include/asm-generic/errno-base.h\n/usr/include/asm-generic/errno.h\n</code></pre> <p>Welche Exit Codes ein Kommando zur\u00fcckgibt, ist in der Regel in der entsprechenden Manpage beschrieben.</p>"},{"location":"samples/bash_variables.html#environmentvariablen","title":"Environmentvariablen","text":"<p>Shellvariablen sind nur in der aktuelle Shell bekannt. Environmentvariablen dagegen werden an alle Subprozesse der Shell vererbt. Ein Subprozess ist ein Prozess, der von der aktuellen Shell gestartet wurde. Eine Variable wird zu einer  Environmentvariablen, indem man sie mit export deklariert:</p> <pre><code>export ENV_VARIABLE=\"Hallo\"\n</code></pre> <p>Oder auch l\u00e4nger:</p> <pre><code>ENV_VARIABLE=\"Hallo\"\nexport ENV_VARIABLE\n</code></pre> <p>All derzeit deklarierten Environmentvariablen kann man sich mit dem folgenden  Kommando ausgeben lassen:</p> <pre><code>env\n</code></pre> <p>Beispiel:</p> <pre><code>$ msg=\"Hello\"\n$ echo \"#!/bin/bash\" &gt;./tmp.bash\n$ echo \"echo \"msg:\\$msg\\\"\" &gt;&gt;./tmp.bash\n$ chmod 700 ./tmp.bash\n$ ./tmp.bash\nmsg:\n$ export msg\n$ ./tmp.bash\nmsg:Hello\n</code></pre>"},{"location":"samples/bash_variables.html#variable-einen-wert-zuweisen-und-ausgeben","title":"Variable einen Wert zuweisen und ausgeben","text":"<pre><code>msg=\"Hello World!\"\necho \"$msg\"\n</code></pre>"},{"location":"samples/bash_variables.html#lange-der-zeichenkette-in-einer-variablen-msg","title":"L\u00e4nge der Zeichenkette in einer Variablen: ${#msg}","text":"<pre><code>echo ${#msg}\n</code></pre>"},{"location":"samples/bash_variables.html#variable-schreibschutzen-readonly","title":"Variable schreibsch\u00fctzen (readonly)","text":"<pre><code>msgr=\"Hello World! #1\"\necho \"$msgr\"\nHello World! #1\n</code></pre> <pre><code>declare -r msgr\nmsgr=\"Hello World! #2\"\nsamples/bash_variables.bash: line 49: msgr: readonly variable\n</code></pre> <pre><code>echo \"$msgr\"\nHello World! #1\n</code></pre>"},{"location":"samples/bash_variables.html#bilden-eines-teilstrings","title":"Bilden eines Teilstrings","text":"<pre><code>echo \"${msg:0:2}\"\n</code></pre> <p>Es werden die Werte mit dem Index 0-1 ausgegeben. Der erste Wert (1) gibt an, ab welchem Index die Ausgabe bebinnt und der zweite Wert (2) gibt den ersten Index an, dessen Wert nicht mehr ausgegeben werden soll.</p>"},{"location":"samples/bash_variables.html#ist-teilstring-in-einem-string-enthalten","title":"Ist Teilstring in einem String enthalten","text":"<pre><code>string='A long string'\nif [[ $string == *\"A long\"* ]]\nthen\n    echo \"'A long' is part of the string\"\nfi\n</code></pre> <pre><code>string='A long string'\nif [[ $string != *\"A short\"* ]]\nthen\n    echo \"'A short' is not part of the string\"\nfi\n</code></pre>"},{"location":"samples/bash_variables.html#ausgabe-eines-programms-in-einer-variablen-speichern","title":"Ausgabe eines Programms in einer Variablen speichern","text":"<pre><code>issue=`cat /etc/issue`\necho \"$issue\"\n</code></pre>"},{"location":"samples/bash_variables.html#ausgabe-eines-programms-in-einer-variablen-speichern_1","title":"Ausgabe eines Programms in einer Variablen speichern","text":"<pre><code>issue=$(cat /etc/issue)\necho \"$issue\"\n</code></pre>"},{"location":"samples/bash_variables.html#erstes-zeichen-in-einen-grobuchstaben-umwandeln","title":"Erstes Zeichen in einen Gro\u00dfbuchstaben umwandeln","text":"<pre><code>echo ${msg^}\n</code></pre>"},{"location":"samples/bash_variables.html#alle-kleinbuchstaben-in-grobuchstaben-umwandeln","title":"Alle Kleinbuchstaben in Gro\u00dfbuchstaben umwandeln","text":"<pre><code>echo ${msg^^}\n</code></pre>"},{"location":"samples/bash_variables.html#alternative-methode-alle-kleinbuchstaben-in-grobuchstaben-umwandeln","title":"Alternative Methode: Alle Kleinbuchstaben in Gro\u00dfbuchstaben umwandeln","text":"<pre><code>echo $uuid | tr '[:lower:]' '[:upper:]'\n</code></pre>"},{"location":"samples/bash_variables.html#erstes-zeichen-in-einen-kleinbuchstaben-umwandeln","title":"Erstes Zeichen in einen Kleinbuchstaben umwandeln","text":"<pre><code>echo ${msg,}\n</code></pre>"},{"location":"samples/bash_variables.html#alle-grobuchstaben-in-kleinbuchstaben-umwandeln","title":"Alle Gro\u00dfbuchstaben in Kleinbuchstaben umwandeln","text":"<pre><code>echo ${msg,,}\n</code></pre>"},{"location":"samples/bash_variables.html#alternative-methode-alle-grobuchstaben-in-kleinbuchstaben-umwandeln","title":"Alternative Methode: Alle Gro\u00dfbuchstaben in Kleinbuchstaben umwandeln","text":"<pre><code>echo $msg | tr '[:upper:]' '[:lower:]'\n</code></pre>"},{"location":"samples/bash_variables.html#prufen-ob-eine-variable-eine-positive-zahl-ohne-vorzeichen-enthalt","title":"Pr\u00fcfen, ob eine Variable eine positive Zahl ohne Vorzeichen + enth\u00e4lt","text":"<pre><code>declare -a inp=(a -1 0 +1 1)\nfor n in ${inp[@]}\ndo\n    if ! [[ \"$n\" =~ ^[1-9][0-9]*$ ]]\n    then\n        echo \"$n - keine positive Zahl Zahl ohne Vorzeichen +\"\n    else\n        echo \"$n - positive Zahl Zahl ohne Vorzeichen +\"\n    fi\ndone\n</code></pre>"},{"location":"samples/bash_variables.html#wert-einer-zahl-erhohen","title":"Wert einer Zahl erh\u00f6hen","text":"<pre><code>zahl=1\necho $zahl\nzahl=`expr $zahl + 1`\necho $zahl\necho \"\"\n</code></pre> <p>Oder:</p> <pre><code>zahl=1\necho $zahl\nzahl=$((zahl + 1))\necho $zahl\necho \"\"\n</code></pre>  <p>Ein Skript, dass alle hier beschriebene Operationen ausf\u00fchrt, findet man hier: bash_variables.bash</p>"},{"location":"samples/date_samples.html","title":"Beispiele f\u00fcr das Kommando date","text":""},{"location":"samples/date_samples.html#einfacher-zeitstempel-fur-logdateien-und-temporare-dateien","title":"Einfacher Zeitstempel f\u00fcr Logdateien und tempor\u00e4re Dateien","text":"<p>Ausgabeformat: YYYYMMDDhhmmss <pre><code>date +\"%Y%m%d%H%M%S\"\n20220205171709\n</code></pre></p>"},{"location":"samples/date_samples.html#rfc3339-zeitstempelformat-erzeugen","title":"RFC3339 Zeitstempelformat erzeugen","text":"<p>RFC3339: Date and Time on the Internet: Timestamps</p> <pre><code>date +\"%Y-%m-%dT%H:%M:%S%:z\"\n2022-02-05T17:17:09+01:00\n</code></pre>"},{"location":"samples/date_samples.html#ausgabe-in-utc-zeit","title":"Ausgabe in UTC Zeit","text":"<pre><code>date --utc +\"%Y-%m-%dT%H:%M:%S%:z\"\n2022-02-05T16:17:09+00:00\n</code></pre>"},{"location":"samples/date_samples.html#iso-8601-zeitstempelformat-erzeugen","title":"ISO 8601 Zeitstempelformat erzeugen","text":"<pre><code>date +\"%Y-%m-%dT%H:%M:%S%z\"\n2022-02-05T17:17:09+0100\n</code></pre> <p>D.h: der einzige Unterschied ist der Doppelpunkt (:) in der Zeitzonenangabe. Das  RFC3339 Format ist aber auch ein g\u00fcltiges ISO 8601 Format.</p> <p>Weitere Details findet man hier: RFC 3339 vs ISO 8601.</p>"},{"location":"samples/date_samples.html#sekunden-seit-dem-01011970-000000-uhr-utc-zeit","title":"Sekunden seit dem 01.01.1970, 00:00:00 Uhr UTC-Zeit","text":"<p>In Linux wird die Zeit intern in Sekunden (oder auch Milli- bzw. Nanosekunden) seit dem 01.01.1970 um 00:00:00 Uhr UTC Zeit berechnet. In vielen Logdateien wird dieser Wert als Zeitstempel benutzt. Mit dme date Kommando kann man sich diesen Wert  ausgeben lassen:</p> <pre><code>date +%s\n1644077829\n</code></pre>"},{"location":"samples/date_samples.html#sekunden-seit-dem-01011970-000000-uhr-utc-zeit-in-datum-umwandeln","title":"Sekunden seit dem 01.01.1970, 00:00:00 Uhr UTC-Zeit in Datum umwandeln","text":"<p>Findet man in einer Logdatei so einen Zeitstempel, kann man ihn mit dem date Kommando einfach in ein Datum samt Uhrzeit.</p> <p>Zuerst holen wir uns einen Zeitstempel (um Beispiel die aktuelle Zeit)</p> <pre><code>now=$(date +%s)\necho \"${now}\"\n1644077829\n</code></pre> <p>Diesen Zeitstempel kann man folgenderma\u00dfen im date Kommando nutzen</p> <pre><code>date --date=@${now}\nSat 05 Feb 2022 05:17:09 PM CET\n</code></pre> <p>Zus\u00e4tzlich kann man auch ein Ausgabeformat angeben (hier das RFC3339 Format)</p> <pre><code>date --date=@${now} +\"%Y-%m-%dT%H:%M:%S%:z\"\n2022-02-05T17:17:09+01:00\n</code></pre> <p>Alternativ kann man auch eine Ausgabe in der UTC Zeit erhalten</p> <pre><code>date --utc --date=@${now} +\"%Y-%m-%dT%H:%M:%S%:z\"\n2022-02-05T16:17:09+00:00\n</code></pre>"},{"location":"samples/date_samples.html#git-letzten-commit-zeitstempel-fur-eine-datei-ausgeben","title":"Git: Letzten commit Zeitstempel f\u00fcr eine Datei ausgeben","text":"<p>Den Zeitstempel, in Sekunden seit dem 01.01.1970, 00:00:00 Uhr UTC-Zeit, erh\u00e4lt man folgenderma\u00dfen:</p> <pre><code>git log -1 --format=%ct docs-src/samples/date_samples.md\n1644230639\n</code></pre> <p>Das zugeh\u00f6rige Datum kann man dann so ausgeben:</p> <pre><code>date --date=@1644230639\nMon 07 Feb 2022 11:43:59 AM CET\n</code></pre> <p>Hier noch der Zeitstempel im RFC3339 Format:</p> <pre><code>date --date=@1644230639 +\"%Y-%m-%dT%H:%M:%S%:z\"\n2022-02-07T11:43:59+01:00\n</code></pre>  <p>Ein Skript, dass alle hier beschriebene Operationen ausf\u00fchrt, findet man hier: date_samples.bash</p>"},{"location":"samples/misc.html","title":"Verschiedenes","text":""},{"location":"samples/misc.html#shell-zen","title":"Shell Zen","text":"<p>zen.bash ist ein kleines Skript zur Entspannung. Wesentlicher Teil des Skripts ist eine  Schleife:</p> <pre><code>count=0\nmaxcount=10\nwhile [ ${count} -lt ${maxcount} ]\ndo\n    ...\n    count=$((count + 1))\ndone\n</code></pre> <p>Ablauf: so lange die Variable count kleiner als die Variable maxcount ist, wird die  Schleife durchlaufen. Am Ende der Schleife wird der Wert der Variablen count um 1 vergr\u00f6\u00dfert.</p>"},{"location":"samples/misc.html#bash-script-template","title":"Bash Script Template","text":"<p>Die Datei template.bash enth\u00e4lt einen einfachen Rahmen zur Erstellung von Bash Skripten mit Optionen und Argumenten.</p> <p>Variablen</p> <ul> <li>SCRIPT_NAME   Diese Variable enth\u00e4lt den Namen des Skripts</li> <li>SCRIPT_DIR   Diese Variable enth\u00e4lt den vollen Pfadnamen des Verzeichnisses, in dem das   Skript abgelegt ist.</li> <li>VERSION   Diese Variable enth\u00e4lt eine Versionsinformation zum Skript.</li> </ul> <p>Weiter Variablen  Diese Variaben sind nur Beispiele, die zeigen sollen, wie man Variablen \u00fcber Optionen setzen kann.</p> <ul> <li>number   Ein Beispiel f\u00fcr eine numerische Variable</li> <li>string   Ein Beispiel f\u00fcr eine String Variable</li> </ul> <p>Optionen</p> <pre><code>-h oder --help     : Ausgabe der Hilfeinformation und beenden des Skripts\n-V oder --version  : Ausgabe der Version und beenden des Skripts\n-n oder --number   : setzen der Variablen number\n-s oder --string   : setzen der Variablen string\n--                 : es wird nicht weiter auf Optionen gepr\u00fcft\n                     sinnvoll, wenn das erste Argument mit - oder --\n                     beginnt.\n</code></pre> <p>Argumente Das Skript erwartet ein Argument. Der Wert wird in der Variablen arg1 abgelegt.</p> <p> Funktion print_usage Gibt den Hilfetext aus</p>"},{"location":"samples/misc.html#passwort-prufen","title":"Passwort pr\u00fcfen","text":"<p>Basierend auf dem heise Artikel Nach dem Passwort-Leak: Eigene Passw\u00f6rter lokal checken habe ich mir das Skript checkPassword.bash geschrieben.</p> <p>Das Skript pr\u00fcft, ob das angegebene Passwort in der Pwned Passwords Datenbank enthalten ist. Man kann das Passwort auch auf der Site angeben, aber es wird dann auch an die Site \u00fcbertragen.</p>"},{"location":"samples/misc.html#beispiel-fur-eine-abfrage-der-daten","title":"Beispiel f\u00fcr eine Abfrage der Daten","text":"<p>Wie man diese Datenbank nutzen kann, ohne das Passwort an die Site zu \u00fcbertragen, ist im heise Artikel beschrieben. Im folgenden Beispiel wird das Passwort  123456 benutzt.</p> <p>Zuerst bildet man den SHA1 (Secure Hash Algorithm 1) Wert des Pasworts:</p> <p><pre><code>$ echo -n \"123456\" | sha1sum\n7c4a8d09ca3762af61e59520943dc26494f8941b  -\n</code></pre> Warum wird echo mit -n aufgerufen?</p> <pre><code>echo \"123456\" | sha1sum\nc4f9375f9834b4e7f0a528cc65c055702bf5f24a  -\n</code></pre> <p>D.h.: man erh\u00e4lt einen anderen Hashwert.</p> <pre><code>$ echo -n \"123456\" | xxd\n00000000: 3132 3334 3536                           123456\n$ echo \"123456\" | xxd\n00000000: 3132 3334 3536 0a                        123456.\n</code></pre> <p>Der Aufruf echo h\u00e4ngt an das Ende der Zeichenkette noch das Steuerzeichen 0x0a an, das f\u00fcr einen Zeilenvorschub sorgt. Da aber nur die Zeichenkette selbst gehasht  werden soll, muss man echo mit der Option -n aufrufen.</p> <p>Am Ende der Ausgabe des Hashwerts steht nach dem Hashwert noch \" -\". Diesen Teil kann man folgenderma\u00dfen entfernen:</p> <pre><code>$ echo -n \"123456\" | sha1sum | awk '{ print $1; }'\n7c4a8d09ca3762af61e59520943dc26494f8941b\n</code></pre> <p>Das awk Kommando bewirkt, dass von jeder gelesen Zeile (hier nur eine Zeile) das  erste Wort ausgegeben wird.</p> <p>Soweit so gut, aber: der Suchstring f\u00fcr die Abfrage muss Gro\u00dfuchstaben statt  Kleinbuchstaben enthalten.</p> <pre><code>$ echo -n \"123456\" | sha1sum | awk '{ print $1; }' | tr '[a-z]' '[A-Z]'\n7C4A8D09CA3762AF61E59520943DC26494F8941B\n</code></pre> <p>Man kann hier auch das folgende verwenden:</p> <pre><code>$ echo -n \"123456\" | sha1sum | awk '{ print $1; }' | tr '[:lower:]' '[:upper:]'\n7C4A8D09CA3762AF61E59520943DC26494F8941B\n</code></pre> <p>F\u00fcr die Suche werden nur die ersten 5 Zeichen (\"7C4A8\") gesendet. Dazu ruft man mit einem HTTP Get Request die folgende URL auf:</p> <p>https://api.pwnedpasswords.com/range/7C4A8</p> <p>Als Ergebnis erh\u00e4lt man eine Liste von Hashwerten (ohne die ersten 5 Zeichen) und die Anzahl der Treffer in der Datenbank. Die Zeilen haben dabei das folgende  Format:</p> <p>: <p>F\u00fcr das Passwort 123456 sieht die Zeile folgenderma\u00dfen aus:</p> <pre><code>D09CA3762AF61E59520943DC26494F8941B:37359195\n</code></pre> <p>Die ben\u00f6tigten Wert kann man sich in der Bash folgenderma\u00dfen in Variablen speichern:</p> <pre><code>hash=`echo -n ${password} | sha1sum | awk '{ print $1; }' | tr '[a-z]' '[A-Z]'`\n#\n# benutze die ersten 5 Zeichen f\u00fcr die Suche\nlookup=${hash:0:5}\n#\n# benutze den Rest als Suchstring in der erhaltenen Liste\nrest=${hash:5}\n</code></pre> <p>Der HTTP Get Request kann in der Shell folgenderma\u00dfen erzeugt werden:</p> <pre><code>curl --tlsv1.3 --silent -o ./checkPassword.bash.txt https://api.pwnedpasswords.com/range/7C4A8\n</code></pre> <p>Hier die Bedeutung der verwendeten curl Optionen:</p> <pre><code>--tlsv1.3    : verwende das TLS 1.3 Protokoll\n--silent     : curl soll keine unn\u00f6tigen Ausgaben machen\n-o dateiname : schreibe die Antwort vom GET Request ind die Datei dateiname\n</code></pre> <p>Die erhaltenen Daten werden in der ./checkPassword.bash.txt gespeichert.</p> <p>Zuerst wird dann gepr\u00fcft, ob es den vom Passwort gebildet Resthash in der Datei gibt. Ist der Exit Code der grep Suche ungleich 0, gabe es keinen Treffer. Gibt es einen  Treffer, wird die Trefferanzahl mit einem sed Aufruf aus der Zeile herausgeholt.</p> <pre><code>grep ${rest} ./checkPassword.bash.txt &gt;/dev/null\nif [ $? -ne 0 ]\nthen\n    echo \"./checkPassword.bash.: password not found\"\nelse\n    echo -n \"./checkPassword.bash: number of hits : \"\n    grep ${rest} ./checkPassword.bash.txt | sed -e 's/^.*://'\nfi\n</code></pre>"},{"location":"samples/misc.html#bespielaufrufe","title":"Bespielaufrufe","text":"<pre><code>$ ./checkPassword.bash 123456\ncheckPassword.bash: number of hits : 37359195\n$ ./checkPassword.bash geheim\ncheckPassword.bash: number of hits : 46130\n$ ./checkPassword.bash secret\ncheckPassword.bash: number of hits : 352091\n$ ./checkPassword.bash DasSuperGeheimePassword\ncheckPassword.bash: password not found\n</code></pre>"},{"location":"woche/index.html","title":"Woche","text":"<p>Der Kurs ist auf 2 Kurswochen ausgelegt. Zu jeder Woche habe ich einige Notizen in diesem Bereich abgelegt.</p> <p>Hinweis: alle Beispiele benutzen die Bash als Shell. En abweichendes Verhalten in anderen Shells ist deshalb m\u00f6glich.</p>"},{"location":"woche/woche1.html","title":"Woche 1","text":"<p>Themen der Woche 1</p> <ul> <li>Was ist Linux und was ist Unix?</li> <li>Was bedeuten die Begriffe Terminal, Shell, Terminalemulator und Konsole?</li> <li>Wie findet man sich in der Kommandozeile zurecht?</li> <li>Wie ist ein Kommando aufgebaut?</li> <li>Welche sind die wichtigsten Kommandos?</li> </ul>"},{"location":"woche/woche1.html#gui-desktop-tastenkombinationen","title":"GUI Desktop Tastenkombinationen","text":"<pre><code>Strg + C\nStrg + D\nStrg + Shift + C        in das Clipboard kopieren\nStrg + Shift + V        aus dem Clipboard einf\u00fcgen\nStrg + L                Bildschirm leeren\nStrg + Alt/Shift + T    Terminalfenster \u00f6ffnen (Alt oder Shift sollte funktionieren)\nTab                     automatische Vervollst\u00e4ndigung\nPfeiltasten oben/unten  zuletzt benutze Befehle\nman &lt;befehl&gt;            \u00f6ffnet das Manual f\u00fcr den entsprechenden Befehl\n</code></pre>"},{"location":"woche/woche1.html#beispiel-fur-eine-package-installation","title":"Beispiel f\u00fcr eine Package Installation","text":"<p>Das Programm sl (steam locomotive - Dampflokomotive) wird folgenderma\u00dfen installiert.</p> <pre><code>sudo apt install sl\n</code></pre> <p>Ruft man dann sl auf</p> <pre><code>/usr/games/sl\n</code></pre> <p>sieht man eine Lokomotive \u00fcber den Bildschirm fahren:</p>  <p>Hinweis: in der Regel ist das Verzeichnis /usr/games nicht im Suchpfad der Shell. Will man nur den Programmnamen ohne Pfad beim Aufruf angeben, gibt es zwei  M\u00f6glichkeiten:</p> <p>Den Suchpfad der Shell erweitern:</p> <pre><code>PATH=$PATH:/usr/games\n</code></pre> <p>Ein alias f\u00fcr das Programm anlegen</p> <pre><code>alias sl='/usr/games/sl'\n</code></pre>"},{"location":"woche/woche1.html#debian-paktetverwaltung","title":"Debian Paktetverwaltung","text":"<p>Wei\u00df man nicht genau, in welchem Debian Paket ein Programm enthalten ist, kann man das Pakte mit Hilfe der Debian-Paketsuche</p>"},{"location":"woche/woche1.html#warum-gibt-es-die-eintrage-und-in-einem-verzeichnis","title":"Warum gibt es die Eintr\u00e4ge . und .. in einem Verzeichnis?","text":"<p>In jedem Verzeichnis gibt es die beiden Eintr\u00e4ge .  und .. :</p> <pre><code>.   verweist auf das aktuelle Verzeichnis\n    cd .  :  es \u00e4ndert sich nicht, ich befinde mich immer \n             noch im gleichen Verzeichnis\n..  verweist auf das \u00fcbergeordnete Verzeichnis (parent directory)\n    cd .. : ich wechsele in das \u00fcbergeordnete Verzeichnis\n</code></pre>"},{"location":"woche/woche1.html#verzeichniseintrag","title":"Verzeichniseintrag ..","text":"<p>Angenommen ich befinde mich derzeit im Verzeichnis /home/openhpi/linux_cli und gebe dort die folgenden Kommandos ein ($ ist das Prompt (Eingabeaufforderung) der Shell.  Die Zeichen nach dem $ sind die Eingaben, die Zeilen ohne $ am Anfang sind die  Ausgaben)</p> <pre><code>$ pwd\n/home/openhpi/linux_cli\n$ find week1-dir -type d -print\nweek1-dir\nweek1-dir/dir3\nweek1-dir/dir2\nweek1-dir/dir2/.hidden\nweek1-dir/dir1\n$ cd week1-dir/dir1\n$ pwd\n/home/openhpi/linux_cli/week1-dir/dir1\n</code></pre> <p>Jetzt m\u00f6chte ich in das Verzeichnis /home/openhpi/linux_cli/week1-dir. Die folgenden cd Kommandos kann man dazu nicht verwenden.</p> <pre><code>$ cd - : wechsele zur\u00fcck in das letzte Verzeichnis (_/home/openhpi/linux_cli_)\n$ cd   : wechsele in das Homeverzeichnis der Kennung  (_/home/openhpi_)\n</code></pre> <p>D.h. ich muss das folgende eingeben:</p> <pre><code>$ cd /home/openhpi/linux_cli/week1-dir\n</code></pre> <p>Mit Hilfe des Verzeichniseintrags .. kann ich aber kurz schreiben</p> <pre><code>$ cd ..\n</code></pre> <p>Vorteil: erstens ist diese Schreibweise k\u00fcrzer - aber viel wichtiger: ich brauche dabei den Namen des Verzeichnisses, in das ich wechseln will, nicht kennen.</p>"},{"location":"woche/woche1.html#kuriose-ausnahme","title":"Kuriose Ausnahme","text":"<p>Das Rootverzeichnis / eines Dateisystems enth\u00e4lt auch die Eintr\u00e4ge . und .. In diesem Fall verweisen sowohl . als auch .. auf /</p>"},{"location":"woche/woche1.html#verzeichniseintrag_1","title":"Verzeichniseintrag .","text":"<p>Der nutzen von .. sollte einigerma\u00dfen klar sein.</p> <p>Frage: warum braucht man den Eintrag . ?</p> <p>Beispiel: in meinem aktuellen Verzeichnis gibt es die ausf\u00fchrbare Datei hallo, die beider Ausf\u00fchrung Hallo ausgibt.</p> <p>Wenn ich den Namen einfach als Kommando in die Shell eingebe, passiert das Folgende:</p> <pre><code>$ hallo\n-bash: hallo: command not found\n</code></pre> <p>Warum ist das so? Die Shell interpretiert hallo als auszuf\u00fchrendes Kommando. Das es kein in die Shell eingebautes Kommando ist, muss sie wissen, wo im Dateisystem die Datei zu finden ist. Dazu benutzt die Shell die Variable PATH</p> <pre><code>$ echo $PATH\n/usr/local/bin:/usr/bin:/bin\n</code></pre> <p>Hier kann man mehrere durch : getrennte Verzeichnisse angeben. Im obigen Beispiel w\u00fcrde die Shell in der folgenden Reihenfolge nach der Datei hallo suchen:</p> <ul> <li>/usr/local/bin/hallo</li> <li>/usr/bin/hallo</li> <li>/bin/hallo</li> </ul> <p>Dabei gilt: der erste Treffer wird ausgef\u00fchrt. Man kann nat\u00fcrlich das akutelle Verzeichnis, in dem man sich befindet, zur Variabeln PATH hinzuf\u00fcgen:</p> <p><pre><code>$ PATH=\"$PATH:$(pwd)\"\n</code></pre> Aber das ist nat\u00fcrlich nicht immer sinnvoll.</p> <p>Will man wissen, wo im Pfad ($PATH) das Kommando gefunden wurde, kann man das Kommando type nutzen:</p> <pre><code>$ type ls\nls is hashed (/bin/ls)\n</code></pre> <p>N\u00e4chster Versuch:</p> <pre><code>$ bash hallo\nHallo\n</code></pre> <p>Sieht gut aus, es kann aber auch das Folgende passieren:</p> <pre><code>bash hallo\nhallo: hallo: cannot execute binary file\n</code></pre> <p>Warum? Beim Aufruf</p> <pre><code>$ bash hallo\n</code></pre> <p>erwartet die Bash, das die Datei hallo ein Bash Skript enth\u00e4lt.</p> <p>Von welchem Typ meine ausf\u00fchrbare Datei ist (Shell Skript oder Programm), sieht man mit dem folgenden Kommando:</p> <pre><code>$ file hallo\nhallo: Bourne-Again shell script, ASCII text executable\n</code></pre> <pre><code>$ file hallo\nhallo: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=1dc10461ed0684ca195d2712ba9a0205d2989543, for GNU/Linux 3.2.0, not stripped\n</code></pre> <p>Ohne den Typ zu kennen, m\u00fcsste man das Skript/Programm folgenderma\u00dfen aufrufen:</p> <pre><code>$ /home/openhpi/linux_cli/week1-dir/dir1/hallo\nHallo\n</code></pre> <p>Mit Hilfe des builtin Kommandos pwd in der Shell geht das auch so:</p> <pre><code>$ $(pwd)/hallo\nHallo\n</code></pre> <p>Da . auf das aktuelle Verzeichnis verweist, kann man aber auch einfach das Folgende aufrufen:</p> <pre><code>$ ./hallo\nHallo\n</code></pre> <p>Sollen immer alle ausf\u00fchrbaren Dateien im aktuellen Verzeichnis von der Shell  gefunden werden, kann man die Variable PATH folgenderma\u00dfen erweitern:</p> <pre><code>$ PATH=\"$PATH:.\"\n</code></pre> <p>Bleibt noch die Frage, warum</p> <pre><code>$ ./hallo\n</code></pre> <p>als Bash Skript ausgef\u00fchrt wird.</p> <p>L\u00f6sung: die Datei Datei sieht folgenderma\u00dfen aus:</p> <pre><code>$ cat hallo\n#!/bin/bash\n#\necho \"Hallo\"\n</code></pre> <p>Wichtig ist hierbei die erste Zeile:</p> <pre><code>#!/bin/bash\n</code></pre> <p>Diese Zeile wird als Shebang bezeichnet.</p> <p>Die Shell nimmt in diesem Fall an, dass die Zeichenkette nach \"#!\" ein Kommando ist. Die Shell ruft dieses Kommando auf und \u00fcbergibt den Rest der Datei an das Kommando.</p>"},{"location":"woche/woche1.html#weitere-informationen","title":"Weitere Informationen","text":"<ul> <li>Wikipedia: Dateisystem</li> <li>Wikipedia: Inode</li> </ul>"},{"location":"woche/woche1.html#daten-fur-die-praktische-ubung-19","title":"Daten f\u00fcr die Praktische \u00dcbung 1.9","text":"<p>Die Daten f\u00fcr die Praktische \u00dcbung 1.9 habe ich hier abgelegt:</p> <ul> <li>week1-dir/   Ausgepacktes Archiv</li> <li>week1-dir.tar.gz   TAR Datei der Daten</li> <li>week1-dir.zip   Die original ZIP Datei</li> </ul> <p>Auspacken der TAR Datei:</p> <p><pre><code>tar xvf week1-dir.tar.gz\n</code></pre> finden.</p>"},{"location":"woche/woche1.html#zusammenfassung-der-woche-1","title":"Zusammenfassung der Woche 1","text":"<p>Linux verwendet, \u00e4hnlich wie Windows, ein  Dateisystem  mit Verzeichnissen und Dateien.</p> <p>Loggt man sich and der Console ein, oder \u00f6ffnet in einer GUI ein Terminalfenster befindet man sich im sogenannten Homeverzeichnis der Kennung. Das Verzeichnis, in dem man sich gerade befindet, kann man sich mit dem Kommando pwd ansehen:</p> <pre><code>$ pwd\n/home/openhpi\n</code></pre> <p>Mit dem Kommando cd kann man das Verzeichnis wechseln.</p> <pre><code>$ cd linux_cli\n$ pwd\n/home/openhpi/linux_cli\n</code></pre> <p>Es gibt 3 spezielle M\u00f6glichkeiten, das Kommando cd zu nutzen:</p> <pre><code>cd   : wechsel in das Homeverzeichnis\ncd ~ : wechsel in das Homeverzeichnis\ncd - : wechsel in das letzte Verzeichnis\n</code></pre> <p>Beispiel:  </p> <pre><code>$ pwd\n/home/openhpi\n$ cd linux_cli\n$ pwd\n/home/openhpi/linux_cli\n$ cd\n$ pwd\n/home/openhpi\n$ cd linux_cli\n$ pwd\n/home/openhpi/linux_cli\n$ cd ~\n$ pwd\n/home/openhpi\n$ cd linux_cli\n$ pwd\n/home/openhpi/linux_cli\n$ cd week1-dir\n$ pwd\n/home/openhpi/linux_cli/week1-dir\n$ cd -\n/home/openhpi/linux_cli\n$ pwd\n/home/openhpi/linux_cli\n</code></pre> <p>Die in einem Verzeichns vorhandenen Verzeichnisse/Dateien kann man sich mit dem Kommando ls ansehen.</p> <p>In Linux gibt es eine Reihe von  Rechte im Dateisystem. Diese Rechte kann man mit dem Kommando chmod ver\u00e4ndern.</p> <p>Zur Installation von Programmen ben\u00f6tigt man eine Administratorberechtigung. In einer Desktop Linux Umgebung ist in der Regle mindestens ein Benutzer so konfiguriert, dass er das Programm sudo aufrufen kann. Dieser Benutzer kann das Software auf dem Rechner installieren.</p> <p>Beispiel:</p> <pre><code>sudo apt install fortune\n</code></pre>"},{"location":"woche/woche2.html","title":"Woche 2","text":"<p>Themen der Woche 2</p> <ul> <li>Pipes und Filters</li> <li>Konsolenanwendungen</li> <li>Komfortabel in der Kommandozeile</li> </ul> <p>In den Videos wird die folgende Beispieldatei genutzt:</p> <ul> <li>rezept.txt</li> </ul>"},{"location":"woche/woche2.html#standard-streams","title":"Standard Streams","text":"<ul> <li>stdin    Stream f\u00fcr die Eingabedaten (z.B. Eingagen \u00fcber die Tastatur)</li> <li>stdout   Stream f\u00fcr die Ausgabedaten</li> <li>stderr   Stream f\u00fcr die Fehlermeldungen</li> </ul>"},{"location":"woche/woche2.html#filter","title":"Filter","text":"<p>Filter sind Programme, die Daten von stdin lesen und nach stdout ausgeben.</p>"},{"location":"woche/woche2.html#pipes-pipelines","title":"Pipes (Pipelines)","text":"<p>Pipes verbinden 2 oder mehr Filter. Dabei wird die stdout Ausgabe des Vorg\u00e4ngers an stdin Eingabe des Nachfolgers weitergeleitet.</p>"},{"location":"woche/woche2.html#hintergrundprozesse","title":"Hintergrundprozesse","text":"<p>Zum Thema jobs (Vodergrund-/Hintergrundprozesse) gibt es einen kurzen  \u00dcbersichtsartikel:  Jobs im Griff mit jobs, bg, fg und &amp;.</p> <p>Erg\u00e4nzend kann man in der Shell noch folgendes nutzen: nach dem Starten eines  Kommandos/Prozesses im Hintergrund kann man sich seine Prozess ID (pid) \u00fcber die  Variable $! holen.</p> <pre><code>sleep 100 &amp;\nbgpid=$!\n</code></pre> <p>Die PID des laufenden Shell Prozesses bekommt man \u00fcber die Variable $$. Wenn man auf  das Ende eine Hintergrundprozesses warten will, geht das \u00fcber das Kommando wait</p> <pre><code>wait $bgpid\n</code></pre> <p>Wie erkenne ich, das ein Prozess ein Hintergrundprozesse meiner Shell ist? Die PPID (Parent PID) des Hintergrundprozesses verweist auf die PID meines Shell Prozesses.</p> <p>Jetzt alles zusammen:</p> <pre><code>sleep 3 &amp;\nbgpid=$!\necho \"pid   : $$\"\necho \"bgpid : $bgpid\"\necho \"\"\nps -opid,ppid,cmd\necho \"----------\"\n#\necho \"\"\nwait $bgpid\nps -opid,ppid,cmd\necho \"----------\"\n</code></pre> <p>Die Ausgabe sieht dann im Wesentlichen so aus (die Prozesse oberhalb von -bash  habe ich aus der Liste gel\u00f6scht):</p> <pre><code>pid   : 1724923\nbgpid : 1724924\n\n    PID    PPID CMD\n1724826 1724825 -bash\n1724923 1724826 /bin/bash ./xx\n1724924 1724923 sleep 3\n1724925 1724923 ps -opid,ppid,cmd\n----------\n\n    PID    PPID CMD\n1724826 1724825 -bash\n1724923 1724826 /bin/bash ./xx\n1724926 1724923 ps -opid,ppid,cmd\n----------\n</code></pre> <p>Der sleep Hintergrundprozess hat die PID 1724924 und die PPID 1724923. Das ist die  PID von meinem laufenden Skript xx.</p>"},{"location":"woche/woche2.html#kommandos-verketten","title":"Kommandos verketten","text":"<p>Man kann in einer Anweisung mehrere Kommandos angeben (verketten). Da jedes  Kommando bei seiner Beendigung einen Exit Code zur\u00fcckliefert, kann man mit Hilfe  dieses Wertes die Abarbeitung der Verkettung steuern.</p> <p>Der Exit Code eines Kommandos ist eine Zahl &gt;=0 und kann direkt nach dem Ende des  Kommandos in der Shell mit der Variablen $? abgefragt werden. Dabei bedeutet 0 ein erfolgreiches Ende des Kommandos und ungleich 0, das ein Fehler im Ablauf des Kommandos aufgetreten ist.</p> <pre><code>$ ls\nweek1-dir\n$ echo $?\n0\n</code></pre> <pre><code>$ ls unbekannteDatei\nls: cannot access 'unbekannteDatei': No such file or directory\n$ echo $?\n2\n</code></pre>"},{"location":"woche/woche2.html#kommandos-bis-zum-ersten-fehler-ausfuhren","title":"Kommandos bis zum ersten Fehler ausf\u00fchren","text":"<pre><code>kommando_1 &amp;&amp; kommando_2 &amp;&amp; ... &amp;&amp; kommando_n\n</code></pre> <p>Die Kommandos werden nacheinander ausgef\u00fchrt, bis ein Fehler in einem Kommando auftritt.</p> <p>Beispiel:</p> <pre><code>ls datei1 &amp;&amp; echo \"wird nur angezeigt, wenn es datei1 gibt\"\n</code></pre>"},{"location":"woche/woche2.html#kommandos-bis-zum-ersten-erfolg-ausfuhren","title":"Kommandos bis zum ersten Erfolg ausf\u00fchren","text":"<pre><code>kommando_1 || kommando_2 || ... || kommando_n\n</code></pre> <p>Die Kommandos werden nacheinander ausgef\u00fchrt, bis das erste Kommando erfolgreich ausgef\u00fchrt wurde.</p> <p>Beispiel:</p> <pre><code>ls datei1 || echo \"wird nur angezeigt, wenn es datei1 nicht gibt\"\n</code></pre>"},{"location":"woche/woche2.html#kommandos-verketten_1","title":"Kommandos verketten","text":"<p>Mit dem Zeichen ; k\u00f6nnen Kommandos verkettet werden</p> <p><pre><code>kommando_1 ; kommando_2 ; ... ; kommando_n\n</code></pre> Alle Kommandos werden nacheinander ausgef\u00fchrt - egal ob ein Fehler aufgetreten ist  oder nicht.</p>"},{"location":"woche/woche2.html#shell-eigenschaften","title":"Shell Eigenschaften","text":""},{"location":"woche/woche2.html#environmentvariablen","title":"Environmentvariablen","text":"<p>Shellvariablen sind nur in der aktuelle Shell bekannt. Environmentvariablen dagegen werden an alle Subprozesse der Shell vererbt. Ein Subprozess ist ein Prozess, der von der aktuellen Shell gestartet wurde. Eine Variable wird zu einer Environmentvariablen, indem man sie mit export deklariert:</p> <pre><code>export ENV_VARIABLE=\"Hallo\"\n</code></pre> <p>Oder auch l\u00e4nger:</p> <pre><code>ENV_VARIABLE=\"Hallo\"\nexport ENV_VARIABLE\n</code></pre> <p>All derzeit deklarierten Environmentvariablen kann man sich mit dem folgenden Kommando ausgeben lassen:</p> <pre><code>env\n</code></pre> <p>Die folgenden Environmentvariablen sind in der Shell immer gesetzt:</p> <ul> <li>HOME   Enth\u00e4lt das Homeverzeichni des Benutzers</li> <li>PATH   Enth\u00e4lt (durch : getrennt) alle Verzeichnisse, in denen die Shell nach einem   Kommando sucht.</li> </ul>"},{"location":"woche/woche2.html#alias-unalias","title":"alias / unalias","text":"<p>Mit alias kann man sich ein eigenes Kommando builden.</p> <pre><code>alias ll='ls -l'\nalias bilder='cd $HOME/Bilder;pwd'\n</code></pre> <p>Gibt man ll ein, wird das Kommando ls -l ausgef\u00fchrt. Gibt man bilder ein, wird die Kommandoverkettung cd $HOME/Bilder;pwd ausgef\u00fchrt.</p> <p>Mit unalias kann man ein vorher erzeugtes Alias l\u00e4schen.</p> <pre><code>unalias ll\n</code></pre> <p>Gibt man nur alias ein, werden alle deklarierten Aliases angezeigt.</p> <pre><code>alias\n</code></pre>"},{"location":"woche/woche2.html#history","title":"History","text":"<p>Die Shell f\u00fchrt eine History der aufgerufenen Kommandos.</p> <pre><code>history     : anzeigen der History\nStrg + R    : suchen in History\n!!          : letztes Komando wiederholen\nKommando !! : Kommando mit dem letzten Kommando als Argument ausf\u00fchren\n</code></pre>"},{"location":"woche/woche2.html#tldr-too-long-didnt-read","title":"TLDR (Too Long Didn't Read)","text":"<p>Die gesamte TLDR Umgebung ist im GitHub unter der Kennung tldr pages abgelegt. Der Standard Client ist ein Python Skript (tldr-python-client). Auf dieser Seite gibt es auch eine Beschreibung zur Konfiguration und dem Aufruf des Clients. Die von tldr ausgegeben Texte sind im Repository tldr-pages/tldr abgelegt.</p>"}]}